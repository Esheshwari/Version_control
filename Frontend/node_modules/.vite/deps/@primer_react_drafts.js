"use client";
import {
  ActionBar,
  ActionList,
  ActionListContainerContext,
  Announce,
  AriaAlert,
  AriaStatus,
  Box,
  ButtonComponent,
  Checkbox,
  ConfirmationDialog,
  Dialog,
  Flash,
  FocusKeys,
  Heading,
  IconButton,
  InputLabel,
  Link,
  LiveRegion,
  LiveRegionOutlet,
  Message,
  NavList,
  Octicon,
  Overlay,
  PageHeader,
  Portal,
  ScrollableRegion,
  SelectPanel,
  SkeletonAvatar,
  SkeletonBox,
  SkeletonText,
  Stack,
  StyledOverlay,
  StyledSpinner,
  StyledUnderlineItemList,
  StyledUnderlineWrapper,
  TabNav$1,
  Text,
  TextInput$1,
  Textarea,
  Tooltip,
  TooltipContext,
  UnderlineItem,
  VisuallyHidden,
  VisuallyHidden2,
  clsx_m_default,
  createComponent,
  defaultSxProp,
  get,
  getBreakpointDeclarations,
  getGlobalFocusStyles,
  heightMap,
  invariant,
  isMacOS,
  require_cjs,
  styled_components_browser_esm_default,
  sx,
  useAnchoredPosition,
  useFocusZone,
  useFormControlForwardedProps,
  useId,
  useIsomorphicLayoutEffect,
  useOverflow,
  useProvidedRefOrCreate,
  useRefObjectAsForwardedRef,
  useResizeObserver,
  useResponsiveValue,
  useSlots,
  viewportRanges,
  warning
} from "./chunk-L4EVFDMX.js";
import {
  AlertFillIcon,
  AlertIcon,
  ArrowLeftIcon,
  BoldIcon,
  CheckCircleFillIcon,
  CheckCircleIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  CodeIcon,
  CrossReferenceIcon,
  FilterRemoveIcon,
  HeadingIcon,
  InfoIcon,
  ItalicIcon,
  LinkIcon,
  ListOrderedIcon,
  ListUnorderedIcon,
  MentionIcon,
  PaperclipIcon,
  QuoteIcon,
  ReplyIcon,
  SearchIcon,
  SortAscIcon,
  SortDescIcon,
  StopIcon,
  TasklistIcon,
  XCircleFillIcon,
  XIcon
} from "./chunk-BGXEC67M.js";
import "./chunk-MUZVRNE6.js";
import {
  require_react_dom
} from "./chunk-WRD5HZVH.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@github/markdown-toolbar-element/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  default: () => dist_default
});
function getButtons(toolbar) {
  const els = [];
  for (const button of toolbar.querySelectorAll(buttonSelectors.join(", "))) {
    if (button.hidden || button.offsetWidth <= 0 && button.offsetHeight <= 0)
      continue;
    if (button.closest("markdown-toolbar") === toolbar)
      els.push(button);
  }
  return els;
}
function keydown(fn) {
  return function(event) {
    if (event.key === " " || event.key === "Enter") {
      fn(event);
    }
  };
}
function applyFromToolbar(event) {
  const { target, currentTarget } = event;
  if (!(target instanceof Element))
    return;
  const mdButton = target.closest("[data-md-button]");
  if (!mdButton || mdButton.closest("markdown-toolbar") !== currentTarget)
    return;
  const mdButtonStyle = mdButton.getAttribute("data-md-button");
  const style = manualStyles[mdButtonStyle];
  if (!style)
    return;
  event.preventDefault();
  applyStyle(target, style);
}
function setFocusManagement(toolbar) {
  toolbar.addEventListener("keydown", focusKeydown);
  toolbar.setAttribute("tabindex", "0");
  toolbar.addEventListener("focus", onToolbarFocus, { once: true });
}
function unsetFocusManagement(toolbar) {
  toolbar.removeEventListener("keydown", focusKeydown);
  toolbar.removeAttribute("tabindex");
  toolbar.removeEventListener("focus", onToolbarFocus);
}
function onToolbarFocus({ target }) {
  if (!(target instanceof Element))
    return;
  target.removeAttribute("tabindex");
  let tabindex = "0";
  for (const button of getButtons(target)) {
    button.setAttribute("tabindex", tabindex);
    if (tabindex === "0") {
      button.focus();
      tabindex = "-1";
    }
  }
}
function focusKeydown(event) {
  const key = event.key;
  if (key !== "ArrowRight" && key !== "ArrowLeft" && key !== "Home" && key !== "End")
    return;
  const toolbar = event.currentTarget;
  if (!(toolbar instanceof HTMLElement))
    return;
  const buttons = getButtons(toolbar);
  const index = buttons.indexOf(event.target);
  const length = buttons.length;
  if (index === -1)
    return;
  let n = 0;
  if (key === "ArrowLeft")
    n = index - 1;
  if (key === "ArrowRight")
    n = index + 1;
  if (key === "End")
    n = length - 1;
  if (n < 0)
    n = length - 1;
  if (n > length - 1)
    n = 0;
  for (let i = 0; i < length; i += 1) {
    buttons[i].setAttribute("tabindex", i === n ? "0" : "-1");
  }
  event.preventDefault();
  buttons[n].focus();
}
function isMultipleLines(string) {
  return string.trim().split("\n").length > 1;
}
function repeat(string, n) {
  return Array(n + 1).join(string);
}
function wordSelectionStart(text, i) {
  let index = i;
  while (text[index] && text[index - 1] != null && !text[index - 1].match(/\s/)) {
    index--;
  }
  return index;
}
function wordSelectionEnd(text, i, multiline) {
  let index = i;
  const breakpoint = multiline ? /\n/ : /\s/;
  while (text[index] && !text[index].match(breakpoint)) {
    index++;
  }
  return index;
}
function insertText(textarea, { text, selectionStart, selectionEnd }) {
  const originalSelectionStart = textarea.selectionStart;
  const before = textarea.value.slice(0, originalSelectionStart);
  const after = textarea.value.slice(textarea.selectionEnd);
  if (canInsertText === null || canInsertText === true) {
    textarea.contentEditable = "true";
    try {
      canInsertText = document.execCommand("insertText", false, text);
    } catch (error) {
      canInsertText = false;
    }
    textarea.contentEditable = "false";
  }
  if (canInsertText && !textarea.value.slice(0, textarea.selectionStart).endsWith(text)) {
    canInsertText = false;
  }
  if (!canInsertText) {
    try {
      document.execCommand("ms-beginUndoUnit");
    } catch (e) {
    }
    textarea.value = before + text + after;
    try {
      document.execCommand("ms-endUndoUnit");
    } catch (e) {
    }
    textarea.dispatchEvent(new CustomEvent("input", { bubbles: true, cancelable: true }));
  }
  if (selectionStart != null && selectionEnd != null) {
    textarea.setSelectionRange(selectionStart, selectionEnd);
  } else {
    textarea.setSelectionRange(originalSelectionStart, textarea.selectionEnd);
  }
}
function styleSelectedText(textarea, styleArgs) {
  const text = textarea.value.slice(textarea.selectionStart, textarea.selectionEnd);
  let result;
  if (styleArgs.orderedList || styleArgs.unorderedList) {
    result = listStyle(textarea, styleArgs);
  } else if (styleArgs.multiline && isMultipleLines(text)) {
    result = multilineStyle(textarea, styleArgs);
  } else {
    result = blockStyle(textarea, styleArgs);
  }
  insertText(textarea, result);
}
function expandSelectionToLine(textarea) {
  const lines = textarea.value.split("\n");
  let counter = 0;
  for (let index = 0; index < lines.length; index++) {
    const lineLength = lines[index].length + 1;
    if (textarea.selectionStart >= counter && textarea.selectionStart < counter + lineLength) {
      textarea.selectionStart = counter;
    }
    if (textarea.selectionEnd >= counter && textarea.selectionEnd < counter + lineLength) {
      textarea.selectionEnd = counter + lineLength - 1;
    }
    counter += lineLength;
  }
}
function expandSelectedText(textarea, prefixToUse, suffixToUse, multiline = false) {
  if (textarea.selectionStart === textarea.selectionEnd) {
    textarea.selectionStart = wordSelectionStart(textarea.value, textarea.selectionStart);
    textarea.selectionEnd = wordSelectionEnd(textarea.value, textarea.selectionEnd, multiline);
  } else {
    const expandedSelectionStart = textarea.selectionStart - prefixToUse.length;
    const expandedSelectionEnd = textarea.selectionEnd + suffixToUse.length;
    const beginsWithPrefix = textarea.value.slice(expandedSelectionStart, textarea.selectionStart) === prefixToUse;
    const endsWithSuffix = textarea.value.slice(textarea.selectionEnd, expandedSelectionEnd) === suffixToUse;
    if (beginsWithPrefix && endsWithSuffix) {
      textarea.selectionStart = expandedSelectionStart;
      textarea.selectionEnd = expandedSelectionEnd;
    }
  }
  return textarea.value.slice(textarea.selectionStart, textarea.selectionEnd);
}
function newlinesToSurroundSelectedText(textarea) {
  const beforeSelection = textarea.value.slice(0, textarea.selectionStart);
  const afterSelection = textarea.value.slice(textarea.selectionEnd);
  const breaksBefore = beforeSelection.match(/\n*$/);
  const breaksAfter = afterSelection.match(/^\n*/);
  const newlinesBeforeSelection = breaksBefore ? breaksBefore[0].length : 0;
  const newlinesAfterSelection = breaksAfter ? breaksAfter[0].length : 0;
  let newlinesToAppend;
  let newlinesToPrepend;
  if (beforeSelection.match(/\S/) && newlinesBeforeSelection < 2) {
    newlinesToAppend = repeat("\n", 2 - newlinesBeforeSelection);
  }
  if (afterSelection.match(/\S/) && newlinesAfterSelection < 2) {
    newlinesToPrepend = repeat("\n", 2 - newlinesAfterSelection);
  }
  if (newlinesToAppend == null) {
    newlinesToAppend = "";
  }
  if (newlinesToPrepend == null) {
    newlinesToPrepend = "";
  }
  return { newlinesToAppend, newlinesToPrepend };
}
function blockStyle(textarea, arg) {
  let newlinesToAppend;
  let newlinesToPrepend;
  const { prefix, suffix, blockPrefix, blockSuffix, replaceNext, prefixSpace, scanFor, surroundWithNewlines } = arg;
  const originalSelectionStart = textarea.selectionStart;
  const originalSelectionEnd = textarea.selectionEnd;
  let selectedText = textarea.value.slice(textarea.selectionStart, textarea.selectionEnd);
  let prefixToUse = isMultipleLines(selectedText) && blockPrefix.length > 0 ? `${blockPrefix}
` : prefix;
  let suffixToUse = isMultipleLines(selectedText) && blockSuffix.length > 0 ? `
${blockSuffix}` : suffix;
  if (prefixSpace) {
    const beforeSelection = textarea.value[textarea.selectionStart - 1];
    if (textarea.selectionStart !== 0 && beforeSelection != null && !beforeSelection.match(/\s/)) {
      prefixToUse = ` ${prefixToUse}`;
    }
  }
  selectedText = expandSelectedText(textarea, prefixToUse, suffixToUse, arg.multiline);
  let selectionStart = textarea.selectionStart;
  let selectionEnd = textarea.selectionEnd;
  const hasReplaceNext = replaceNext.length > 0 && suffixToUse.indexOf(replaceNext) > -1 && selectedText.length > 0;
  if (surroundWithNewlines) {
    const ref = newlinesToSurroundSelectedText(textarea);
    newlinesToAppend = ref.newlinesToAppend;
    newlinesToPrepend = ref.newlinesToPrepend;
    prefixToUse = newlinesToAppend + prefix;
    suffixToUse += newlinesToPrepend;
  }
  if (selectedText.startsWith(prefixToUse) && selectedText.endsWith(suffixToUse)) {
    const replacementText = selectedText.slice(prefixToUse.length, selectedText.length - suffixToUse.length);
    if (originalSelectionStart === originalSelectionEnd) {
      let position = originalSelectionStart - prefixToUse.length;
      position = Math.max(position, selectionStart);
      position = Math.min(position, selectionStart + replacementText.length);
      selectionStart = selectionEnd = position;
    } else {
      selectionEnd = selectionStart + replacementText.length;
    }
    return { text: replacementText, selectionStart, selectionEnd };
  } else if (!hasReplaceNext) {
    let replacementText = prefixToUse + selectedText + suffixToUse;
    selectionStart = originalSelectionStart + prefixToUse.length;
    selectionEnd = originalSelectionEnd + prefixToUse.length;
    const whitespaceEdges = selectedText.match(/^\s*|\s*$/g);
    if (arg.trimFirst && whitespaceEdges) {
      const leadingWhitespace = whitespaceEdges[0] || "";
      const trailingWhitespace = whitespaceEdges[1] || "";
      replacementText = leadingWhitespace + prefixToUse + selectedText.trim() + suffixToUse + trailingWhitespace;
      selectionStart += leadingWhitespace.length;
      selectionEnd -= trailingWhitespace.length;
    }
    return { text: replacementText, selectionStart, selectionEnd };
  } else if (scanFor.length > 0 && selectedText.match(scanFor)) {
    suffixToUse = suffixToUse.replace(replaceNext, selectedText);
    const replacementText = prefixToUse + suffixToUse;
    selectionStart = selectionEnd = selectionStart + prefixToUse.length;
    return { text: replacementText, selectionStart, selectionEnd };
  } else {
    const replacementText = prefixToUse + selectedText + suffixToUse;
    selectionStart = selectionStart + prefixToUse.length + selectedText.length + suffixToUse.indexOf(replaceNext);
    selectionEnd = selectionStart + replaceNext.length;
    return { text: replacementText, selectionStart, selectionEnd };
  }
}
function multilineStyle(textarea, arg) {
  const { prefix, suffix, surroundWithNewlines } = arg;
  let text = textarea.value.slice(textarea.selectionStart, textarea.selectionEnd);
  let selectionStart = textarea.selectionStart;
  let selectionEnd = textarea.selectionEnd;
  const lines = text.split("\n");
  const undoStyle = lines.every((line) => line.startsWith(prefix) && line.endsWith(suffix));
  if (undoStyle) {
    text = lines.map((line) => line.slice(prefix.length, line.length - suffix.length)).join("\n");
    selectionEnd = selectionStart + text.length;
  } else {
    text = lines.map((line) => prefix + line + suffix).join("\n");
    if (surroundWithNewlines) {
      const { newlinesToAppend, newlinesToPrepend } = newlinesToSurroundSelectedText(textarea);
      selectionStart += newlinesToAppend.length;
      selectionEnd = selectionStart + text.length;
      text = newlinesToAppend + text + newlinesToPrepend;
    }
  }
  return { text, selectionStart, selectionEnd };
}
function undoOrderedListStyle(text) {
  const lines = text.split("\n");
  const orderedListRegex = /^\d+\.\s+/;
  const shouldUndoOrderedList = lines.every((line) => orderedListRegex.test(line));
  let result = lines;
  if (shouldUndoOrderedList) {
    result = lines.map((line) => line.replace(orderedListRegex, ""));
  }
  return {
    text: result.join("\n"),
    processed: shouldUndoOrderedList
  };
}
function undoUnorderedListStyle(text) {
  const lines = text.split("\n");
  const unorderedListPrefix = "- ";
  const shouldUndoUnorderedList = lines.every((line) => line.startsWith(unorderedListPrefix));
  let result = lines;
  if (shouldUndoUnorderedList) {
    result = lines.map((line) => line.slice(unorderedListPrefix.length, line.length));
  }
  return {
    text: result.join("\n"),
    processed: shouldUndoUnorderedList
  };
}
function makePrefix(index, unorderedList) {
  if (unorderedList) {
    return "- ";
  } else {
    return `${index + 1}. `;
  }
}
function clearExistingListStyle(style, selectedText) {
  let undoResultOpositeList;
  let undoResult;
  let pristineText;
  if (style.orderedList) {
    undoResult = undoOrderedListStyle(selectedText);
    undoResultOpositeList = undoUnorderedListStyle(undoResult.text);
    pristineText = undoResultOpositeList.text;
  } else {
    undoResult = undoUnorderedListStyle(selectedText);
    undoResultOpositeList = undoOrderedListStyle(undoResult.text);
    pristineText = undoResultOpositeList.text;
  }
  return [undoResult, undoResultOpositeList, pristineText];
}
function listStyle(textarea, style) {
  const noInitialSelection = textarea.selectionStart === textarea.selectionEnd;
  let selectionStart = textarea.selectionStart;
  let selectionEnd = textarea.selectionEnd;
  expandSelectionToLine(textarea);
  const selectedText = textarea.value.slice(textarea.selectionStart, textarea.selectionEnd);
  const [undoResult, undoResultOpositeList, pristineText] = clearExistingListStyle(style, selectedText);
  const prefixedLines = pristineText.split("\n").map((value, index) => {
    return `${makePrefix(index, style.unorderedList)}${value}`;
  });
  const totalPrefixLength = prefixedLines.reduce((previousValue, _currentValue, currentIndex) => {
    return previousValue + makePrefix(currentIndex, style.unorderedList).length;
  }, 0);
  const totalPrefixLengthOpositeList = prefixedLines.reduce((previousValue, _currentValue, currentIndex) => {
    return previousValue + makePrefix(currentIndex, !style.unorderedList).length;
  }, 0);
  if (undoResult.processed) {
    if (noInitialSelection) {
      selectionStart = Math.max(selectionStart - makePrefix(0, style.unorderedList).length, 0);
      selectionEnd = selectionStart;
    } else {
      selectionStart = textarea.selectionStart;
      selectionEnd = textarea.selectionEnd - totalPrefixLength;
    }
    return { text: pristineText, selectionStart, selectionEnd };
  }
  const { newlinesToAppend, newlinesToPrepend } = newlinesToSurroundSelectedText(textarea);
  const text = newlinesToAppend + prefixedLines.join("\n") + newlinesToPrepend;
  if (noInitialSelection) {
    selectionStart = Math.max(selectionStart + makePrefix(0, style.unorderedList).length + newlinesToAppend.length, 0);
    selectionEnd = selectionStart;
  } else {
    if (undoResultOpositeList.processed) {
      selectionStart = Math.max(textarea.selectionStart + newlinesToAppend.length, 0);
      selectionEnd = textarea.selectionEnd + newlinesToAppend.length + totalPrefixLength - totalPrefixLengthOpositeList;
    } else {
      selectionStart = Math.max(textarea.selectionStart + newlinesToAppend.length, 0);
      selectionEnd = textarea.selectionEnd + newlinesToAppend.length + totalPrefixLength;
    }
  }
  return { text, selectionStart, selectionEnd };
}
function applyStyle(button, stylesToApply) {
  const toolbar = button.closest("markdown-toolbar");
  if (!(toolbar instanceof MarkdownToolbarElement))
    return;
  const defaults = {
    prefix: "",
    suffix: "",
    blockPrefix: "",
    blockSuffix: "",
    multiline: false,
    replaceNext: "",
    prefixSpace: false,
    scanFor: "",
    surroundWithNewlines: false,
    orderedList: false,
    unorderedList: false,
    trimFirst: false
  };
  const style = Object.assign(Object.assign({}, defaults), stylesToApply);
  const field = toolbar.field;
  if (field) {
    field.focus();
    styleSelectedText(field, style);
  }
}
var __classPrivateFieldGet, _MarkdownHeaderButtonElement_instances, _MarkdownHeaderButtonElement_setLevelStyle, buttonSelectors, styles, manualStyles, MarkdownButtonElement, MarkdownHeaderButtonElement, MarkdownBoldButtonElement, MarkdownItalicButtonElement, MarkdownQuoteButtonElement, MarkdownCodeButtonElement, MarkdownLinkButtonElement, MarkdownImageButtonElement, MarkdownUnorderedListButtonElement, MarkdownOrderedListButtonElement, MarkdownTaskListButtonElement, MarkdownMentionButtonElement, MarkdownRefButtonElement, MarkdownStrikethroughButtonElement, MarkdownToolbarElement, canInsertText, dist_default;
var init_dist = __esm({
  "node_modules/@github/markdown-toolbar-element/dist/index.js"() {
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    buttonSelectors = [
      "[data-md-button]",
      "md-header",
      "md-bold",
      "md-italic",
      "md-quote",
      "md-code",
      "md-link",
      "md-image",
      "md-unordered-list",
      "md-ordered-list",
      "md-task-list",
      "md-mention",
      "md-ref",
      "md-strikethrough"
    ];
    styles = /* @__PURE__ */ new WeakMap();
    manualStyles = {
      "header-1": { prefix: "# " },
      "header-2": { prefix: "## " },
      "header-3": { prefix: "### " },
      "header-4": { prefix: "#### " },
      "header-5": { prefix: "##### " },
      "header-6": { prefix: "###### " },
      bold: { prefix: "**", suffix: "**", trimFirst: true },
      italic: { prefix: "_", suffix: "_", trimFirst: true },
      quote: { prefix: "> ", multiline: true, surroundWithNewlines: true },
      code: {
        prefix: "`",
        suffix: "`",
        blockPrefix: "```",
        blockSuffix: "```"
      },
      link: { prefix: "[", suffix: "](url)", replaceNext: "url", scanFor: "https?://" },
      image: { prefix: "![", suffix: "](url)", replaceNext: "url", scanFor: "https?://" },
      "unordered-list": {
        prefix: "- ",
        multiline: true,
        unorderedList: true
      },
      "ordered-list": {
        prefix: "1. ",
        multiline: true,
        orderedList: true
      },
      "task-list": { prefix: "- [ ] ", multiline: true, surroundWithNewlines: true },
      mention: { prefix: "@", prefixSpace: true },
      ref: { prefix: "#", prefixSpace: true },
      strikethrough: { prefix: "~~", suffix: "~~", trimFirst: true }
    };
    MarkdownButtonElement = class extends HTMLElement {
      constructor() {
        super();
        const apply = (event) => {
          const style = styles.get(this);
          if (!style)
            return;
          event.preventDefault();
          applyStyle(this, style);
        };
        this.addEventListener("keydown", keydown(apply));
        this.addEventListener("click", apply);
      }
      connectedCallback() {
        if (!this.hasAttribute("role")) {
          this.setAttribute("role", "button");
        }
      }
      click() {
        const style = styles.get(this);
        if (!style)
          return;
        applyStyle(this, style);
      }
    };
    MarkdownHeaderButtonElement = class extends MarkdownButtonElement {
      constructor() {
        super(...arguments);
        _MarkdownHeaderButtonElement_instances.add(this);
      }
      connectedCallback() {
        const level = parseInt(this.getAttribute("level") || "3", 10);
        __classPrivateFieldGet(this, _MarkdownHeaderButtonElement_instances, "m", _MarkdownHeaderButtonElement_setLevelStyle).call(this, level);
      }
      static get observedAttributes() {
        return ["level"];
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (name !== "level")
          return;
        const level = parseInt(newValue || "3", 10);
        __classPrivateFieldGet(this, _MarkdownHeaderButtonElement_instances, "m", _MarkdownHeaderButtonElement_setLevelStyle).call(this, level);
      }
    };
    _MarkdownHeaderButtonElement_instances = /* @__PURE__ */ new WeakSet(), _MarkdownHeaderButtonElement_setLevelStyle = function _MarkdownHeaderButtonElement_setLevelStyle2(level) {
      if (level < 1 || level > 6) {
        return;
      }
      const prefix = `${"#".repeat(level)} `;
      styles.set(this, {
        prefix
      });
    };
    if (!window.customElements.get("md-header")) {
      window.MarkdownHeaderButtonElement = MarkdownHeaderButtonElement;
      window.customElements.define("md-header", MarkdownHeaderButtonElement);
    }
    MarkdownBoldButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "**", suffix: "**", trimFirst: true });
      }
    };
    if (!window.customElements.get("md-bold")) {
      window.MarkdownBoldButtonElement = MarkdownBoldButtonElement;
      window.customElements.define("md-bold", MarkdownBoldButtonElement);
    }
    MarkdownItalicButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "_", suffix: "_", trimFirst: true });
      }
    };
    if (!window.customElements.get("md-italic")) {
      window.MarkdownItalicButtonElement = MarkdownItalicButtonElement;
      window.customElements.define("md-italic", MarkdownItalicButtonElement);
    }
    MarkdownQuoteButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "> ", multiline: true, surroundWithNewlines: true });
      }
    };
    if (!window.customElements.get("md-quote")) {
      window.MarkdownQuoteButtonElement = MarkdownQuoteButtonElement;
      window.customElements.define("md-quote", MarkdownQuoteButtonElement);
    }
    MarkdownCodeButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "`", suffix: "`", blockPrefix: "```", blockSuffix: "```" });
      }
    };
    if (!window.customElements.get("md-code")) {
      window.MarkdownCodeButtonElement = MarkdownCodeButtonElement;
      window.customElements.define("md-code", MarkdownCodeButtonElement);
    }
    MarkdownLinkButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "[", suffix: "](url)", replaceNext: "url", scanFor: "https?://" });
      }
    };
    if (!window.customElements.get("md-link")) {
      window.MarkdownLinkButtonElement = MarkdownLinkButtonElement;
      window.customElements.define("md-link", MarkdownLinkButtonElement);
    }
    MarkdownImageButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "![", suffix: "](url)", replaceNext: "url", scanFor: "https?://" });
      }
    };
    if (!window.customElements.get("md-image")) {
      window.MarkdownImageButtonElement = MarkdownImageButtonElement;
      window.customElements.define("md-image", MarkdownImageButtonElement);
    }
    MarkdownUnorderedListButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "- ", multiline: true, unorderedList: true });
      }
    };
    if (!window.customElements.get("md-unordered-list")) {
      window.MarkdownUnorderedListButtonElement = MarkdownUnorderedListButtonElement;
      window.customElements.define("md-unordered-list", MarkdownUnorderedListButtonElement);
    }
    MarkdownOrderedListButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "1. ", multiline: true, orderedList: true });
      }
    };
    if (!window.customElements.get("md-ordered-list")) {
      window.MarkdownOrderedListButtonElement = MarkdownOrderedListButtonElement;
      window.customElements.define("md-ordered-list", MarkdownOrderedListButtonElement);
    }
    MarkdownTaskListButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "- [ ] ", multiline: true, surroundWithNewlines: true });
      }
    };
    if (!window.customElements.get("md-task-list")) {
      window.MarkdownTaskListButtonElement = MarkdownTaskListButtonElement;
      window.customElements.define("md-task-list", MarkdownTaskListButtonElement);
    }
    MarkdownMentionButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "@", prefixSpace: true });
      }
    };
    if (!window.customElements.get("md-mention")) {
      window.MarkdownMentionButtonElement = MarkdownMentionButtonElement;
      window.customElements.define("md-mention", MarkdownMentionButtonElement);
    }
    MarkdownRefButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "#", prefixSpace: true });
      }
    };
    if (!window.customElements.get("md-ref")) {
      window.MarkdownRefButtonElement = MarkdownRefButtonElement;
      window.customElements.define("md-ref", MarkdownRefButtonElement);
    }
    MarkdownStrikethroughButtonElement = class extends MarkdownButtonElement {
      connectedCallback() {
        styles.set(this, { prefix: "~~", suffix: "~~", trimFirst: true });
      }
    };
    if (!window.customElements.get("md-strikethrough")) {
      window.MarkdownStrikethroughButtonElement = MarkdownStrikethroughButtonElement;
      window.customElements.define("md-strikethrough", MarkdownStrikethroughButtonElement);
    }
    MarkdownToolbarElement = class extends HTMLElement {
      connectedCallback() {
        if (!this.hasAttribute("role")) {
          this.setAttribute("role", "toolbar");
        }
        if (!this.hasAttribute("data-no-focus")) {
          setFocusManagement(this);
        }
        this.addEventListener("keydown", keydown(applyFromToolbar));
        this.addEventListener("click", applyFromToolbar);
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (name !== "data-no-focus")
          return;
        if (newValue === null) {
          setFocusManagement(this);
        } else {
          unsetFocusManagement(this);
        }
      }
      disconnectedCallback() {
        unsetFocusManagement(this);
      }
      get field() {
        const id = this.getAttribute("for");
        if (!id)
          return null;
        const root2 = "getRootNode" in this ? this.getRootNode() : document;
        let field;
        if (root2 instanceof Document || root2 instanceof ShadowRoot) {
          field = root2.getElementById(id);
        }
        return field instanceof HTMLTextAreaElement ? field : null;
      }
    };
    MarkdownToolbarElement.observedAttributes = ["data-no-focus"];
    if (!window.customElements.get("markdown-toolbar")) {
      window.MarkdownToolbarElement = MarkdownToolbarElement;
      window.customElements.define("markdown-toolbar", MarkdownToolbarElement);
    }
    canInsertText = null;
    dist_default = MarkdownToolbarElement;
  }
});

// node_modules/@primer/react/lib-esm/Blankslate/Blankslate.js
var import_react = __toESM(require_react());
var StyledBlankslate = styled_components_browser_esm_default.div.withConfig({
  displayName: "Blankslate__StyledBlankslate",
  componentId: "sc-4802l5-0"
})(["container-type:inline-size;.Blankslate{--blankslate-outer-padding-block:var(--base-size-32,2rem);--blankslate-outer-padding-inline:var(--base-size-32,2rem);display:grid;justify-items:center;padding:var(--blankslate-outer-padding-block) var(--blankslate-outer-padding-inline);}.Blankslate[data-spacious='true']{--blankslate-outer-padding-block:var(--base-size-80,5rem);--blankslate-outer-padding-inline:var(--base-size-40,2.5rem);}.Blankslate[data-border='true']{border:var(--borderWidth-thin) solid var(--borderColor-default,", ");border-radius:var(--borderRadius-medium);}.Blankslate[data-narrow='true']{margin:0 auto;max-width:485px;}.Blankslate-Heading,.Blankslate-Description{margin:0;margin-bottom:var(--stack-gap-condensed,0.5rem);}.Blankslate-Heading{font-size:var(--text-title-size-medium,1.25rem);font-weight:var(--text-title-weight-medium,600);}.Blankslate-Description{color:var(--fgColor-muted,", ");font-size:var(--text-body-size-large,1rem);line-height:var(--text-body-lineHeight-large,1.5);}.Blankslate-Action{margin-top:var(--stack-gap-normal,1rem);}.Blankslate-Action:first-of-type{margin-top:var(--stack-gap-spacious,1.5rem);}.Blankslate-Action:last-of-type{margin-bottom:var(--stack-gap-condensed,0.5rem);}"], get("colors.border.default"), get("colors.fg.muted"));
var BlankslateContainerQuery = `
  /* At the time these styles were written,
  34rem was our "small" breakpoint width */
  @container (max-width: 34rem) {
    ${StyledBlankslate} .Blankslate {
    --blankslate-outer-padding-block: var(--base-size-20);
    --blankslate-outer-padding-inline: var(--base-size-20);
  }

  ${StyledBlankslate} .Blankslate[data-spacious='true'] {
    --blankslate-outer-padding-block: var(--base-size-44);
    --blankslate-outer-padding-inline: var(--base-size-28);
  }

  ${StyledBlankslate} .Blankslate-Visual {
    margin-bottom: var(--stack-gap-condensed, 0.5rem);
    max-width: var(--base-size-24);
  }

  ${StyledBlankslate} .Blankslate-Visual svg {
    width: 100%;
  }

  ${StyledBlankslate} .Blankslate-Heading {
    font-size: var(--text-title-size-small);
  }

  ${StyledBlankslate} .Blankslate-Description {
    font-size: var(--text-body-size-medium);
  }

  ${StyledBlankslate} .Blankslate-Action {
    margin-top: var(--stack-gap-condensed, 0.5rem);
  }

  ${StyledBlankslate} .Blankslate-Action:first-of-type {
    margin-top: var(--stack-gap-normal, 1rem);
  }

  ${StyledBlankslate} .Blankslate-Action:last-of-type {
    margin-bottom: calc(var(--stack-gap-condensed, 0.5rem) / 2);
  }
`;
function Blankslate({
  border,
  children,
  narrow,
  spacious
}) {
  return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement("style", {
    type: "text/css",
    dangerouslySetInnerHTML: {
      __html: BlankslateContainerQuery
    }
  }), import_react.default.createElement(StyledBlankslate, null, import_react.default.createElement("div", {
    className: "Blankslate",
    "data-border": border,
    "data-narrow": narrow,
    "data-spacious": spacious
  }, children)));
}
function Visual({
  children
}) {
  return import_react.default.createElement("span", {
    className: "Blankslate-Visual"
  }, children);
}
Visual.displayName = "Visual";
function Heading2({
  as = "h2",
  children
}) {
  return import_react.default.createElement(Box, {
    as,
    className: "Blankslate-Heading"
  }, children);
}
Heading2.displayName = "Heading";
function Description({
  children
}) {
  return import_react.default.createElement("p", {
    className: "Blankslate-Description"
  }, children);
}
Description.displayName = "Description";
function PrimaryAction({
  children,
  href
}) {
  return import_react.default.createElement("div", {
    className: "Blankslate-Action"
  }, import_react.default.createElement(ButtonComponent, {
    as: "a",
    href,
    variant: "primary"
  }, children));
}
PrimaryAction.displayName = "PrimaryAction";
function SecondaryAction({
  children,
  href
}) {
  return import_react.default.createElement("div", {
    className: "Blankslate-Action"
  }, import_react.default.createElement(Link, {
    href
  }, children));
}
SecondaryAction.displayName = "SecondaryAction";
var Blankslate$1 = Object.assign(Blankslate, {
  Visual,
  Heading: Heading2,
  Description,
  PrimaryAction,
  SecondaryAction
});

// node_modules/@primer/react/lib-esm/Banner/Banner.js
var import_react3 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/internal/hooks/useMergedRefs.js
var import_react2 = __toESM(require_react());
function useMergedRefs(...refs) {
  return (0, import_react2.useCallback)((instance) => {
    for (const ref of refs) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref) {
        ref.current = instance;
      }
    }
  }, refs);
}

// node_modules/@primer/react/lib-esm/Banner/Banner.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var iconForVariant = {
  critical: import_react3.default.createElement(StopIcon, null),
  info: import_react3.default.createElement(InfoIcon, null),
  success: import_react3.default.createElement(CheckCircleIcon, null),
  upsell: import_react3.default.createElement(InfoIcon, null),
  warning: import_react3.default.createElement(AlertIcon, null)
};
var labels = {
  critical: "Critical",
  info: "Information",
  success: "Success",
  upsell: "Recommendation",
  warning: "Warning"
};
var Banner = import_react3.default.forwardRef(function Banner2({
  "aria-label": label,
  children,
  description,
  hideTitle,
  icon,
  onDismiss,
  primaryAction,
  secondaryAction,
  title,
  variant = "info",
  ...rest
}, forwardRef7) {
  const dismissible = variant !== "critical" && onDismiss;
  const hasActions = primaryAction || secondaryAction;
  const bannerRef = import_react3.default.useRef(null);
  const ref = useMergedRefs(forwardRef7, bannerRef);
  if (true) {
    (0, import_react3.useEffect)(() => {
      if (title) {
        return;
      }
      const {
        current: banner
      } = bannerRef;
      if (!banner) {
        return;
      }
      const hasTitle = banner.querySelector("[data-banner-title]");
      if (!hasTitle) {
        throw new Error("Expected a title to be provided to the <Banner> component with the `title` prop or through `<Banner.Title>` but no title was found");
      }
    }, [title]);
  }
  return import_react3.default.createElement(StyledBanner, _extends({}, rest, {
    "aria-label": label !== null && label !== void 0 ? label : labels[variant],
    as: "section",
    "data-dismissible": onDismiss ? "" : void 0,
    "data-title-hidden": hideTitle ? "" : void 0,
    "data-variant": variant,
    tabIndex: -1,
    ref
  }), import_react3.default.createElement("style", null, BannerContainerQuery), import_react3.default.createElement("div", {
    className: "BannerIcon"
  }, icon && variant === "info" ? icon : iconForVariant[variant]), import_react3.default.createElement("div", {
    className: "BannerContainer"
  }, import_react3.default.createElement("div", {
    className: "BannerContent"
  }, title ? hideTitle ? import_react3.default.createElement(VisuallyHidden, null, import_react3.default.createElement(BannerTitle, null, title)) : import_react3.default.createElement(BannerTitle, null, title) : null, description ? import_react3.default.createElement(BannerDescription, null, description) : null, children), hasActions ? import_react3.default.createElement(BannerActions, {
    primaryAction,
    secondaryAction
  }) : null), dismissible ? import_react3.default.createElement(IconButton, {
    "aria-label": "Dismiss banner",
    onClick: onDismiss,
    className: "BannerDismiss",
    icon: XIcon,
    variant: "invisible"
  }) : null);
});
var StyledBanner = styled_components_browser_esm_default.div.withConfig({
  displayName: "Banner__StyledBanner",
  componentId: "sc-1n1s78v-0"
})(["display:grid;grid-template-columns:auto minmax(0,1fr) auto;align-items:start;background-color:var(--banner-bgColor);border:var(--borderWidth-thin,1px) solid var(--banner-borderColor);padding:var(--base-size-8,0.5rem);border-radius:var(--borderRadius-medium,", ");@supports (container-type:inline-size){container:banner / inline-size;}&[data-variant='critical']{--banner-bgColor:", ";--banner-borderColor:", ";--banner-icon-fgColor:", ";}&[data-variant='info']{--banner-bgColor:", ";--banner-borderColor:", ";--banner-icon-fgColor:", ";}&[data-variant='success']{--banner-bgColor:", ";--banner-borderColor:", ";--banner-icon-fgColor:", ";}&[data-variant='upsell']{--banner-bgColor:var(--bgColor-upsell-muted,", ");--banner-borderColor:var(--borderColor-upsell-muted,", ");--banner-icon-fgColor:var(--fgColor-upsell-muted,", ");}&[data-variant='warning']{--banner-bgColor:", ";--banner-borderColor:", ";--banner-icon-fgColor:", ";}.BannerIcon{display:grid;place-items:center;padding:var(--base-size-8,0.5rem);}.BannerIcon svg{color:var(--banner-icon-fgColor);fill:var(--banner-icon-fgColor);height:var(--base-size-20,1.25rem);}&[data-title-hidden=''] .BannerIcon svg{height:var(--base-size-16,1rem);}.BannerContainer{font-size:var(--text-body-size-medium,0.875rem);align-items:start;line-height:var(--text-body-lineHeight-medium,calc(20 / 14));row-gap:var(--base-size-4,0.25rem);column-gap:var(--base-size-4,0.25rem);}& :where(.BannerContainer){display:flex;flex-wrap:wrap;justify-content:space-between;}&[data-dismissible] .BannerContainer{display:grid;grid-template-columns:auto;grid-template-rows:auto;}.BannerContent{display:grid;row-gap:var(--base-size-4,0.25rem);grid-column-start:1;margin-block:var(--base-size-8,0.5rem);}&[data-title-hidden=''] .BannerContent{margin-block:var(--base-size-6,0.375rem);}@media screen and (min-width:544px){.BannerContent{flex:1 1 0%;}}.BannerTitle{margin:0;font-size:inherit;font-weight:var(--base-text-weight-semibold,600);}.BannerActionsContainer{display:flex;column-gap:var(--base-size-8,0.5rem);align-items:center;}.BannerActions :where([data-primary-action='trailing']){display:none;}@media screen and (min-width:544px){.BannerActions :where([data-primary-action='trailing']){display:flex;}.BannerActions :where([data-primary-action='leading']){display:none;}}&[data-dismissible] .BannerActions{margin-block-end:var(--size-small,0.375rem);}&[data-dismissible] .BannerActionsContainer[data-primary-action='trailing']{display:none;}&[data-dismissible] .BannerActionsContainer[data-primary-action='leading']{display:flex;}.BannerDismiss{display:grid;place-items:center;padding:var(--base-size-8,0.5rem);margin-inline-start:var(--base-size-4,0.25rem);}.BannerDismiss svg{color:var(--banner-icon-fgColor);}"], get("radii.2"), get("colors.danger.subtle"), get("colors.danger.muted"), get("colors.danger.fg"), get("colors.accent.subtle"), get("colors.accent.muted"), get("colors.accent.fg"), get("colors.success.subtle"), get("colors.success.muted"), get("colors.success.fg"), get("colors.done.subtle"), get("colors.done.muted"), get("colors.done.fg"), get("colors.attention.subtle"), get("colors.attention.muted"), get("colors.attention.fg"));
var BannerContainerQuery = `
  @container banner (max-width: 500px) {
    .BannerContainer {
      display: grid;
      grid-template-rows: auto auto;
    }

    .BannerActions {
      margin-block-end: var(--size-small, 0.375rem);
    }

    .BannerActions [data-primary-action="trailing"] {
      display: none;
    }

    .BannerActions [data-primary-action="leading"] {
      display: flex;
    }
  }

  @container banner (min-width: 500px) {
    .BannerContainer {
      display: grid;
      grid-template-columns: auto auto;
    }

    .BannerActions [data-primary-action="trailing"] {
      display: flex;
    }

    .BannerActions [data-primary-action="leading"] {
      display: none;
    }
  }
`;
function BannerTitle(props) {
  const {
    as: Heading3 = "h2",
    className,
    children,
    ...rest
  } = props;
  return import_react3.default.createElement(Heading3, _extends({}, rest, {
    className: clsx_m_default("BannerTitle", className),
    "data-banner-title": ""
  }), children);
}
BannerTitle.displayName = "BannerTitle";
function BannerDescription({
  children,
  className,
  ...rest
}) {
  return import_react3.default.createElement("div", _extends({}, rest, {
    className: clsx_m_default("BannerDescription", className)
  }), children);
}
BannerDescription.displayName = "BannerDescription";
function BannerActions({
  primaryAction,
  secondaryAction
}) {
  return import_react3.default.createElement("div", {
    className: "BannerActions"
  }, import_react3.default.createElement("div", {
    className: "BannerActionsContainer",
    "data-primary-action": "trailing"
  }, secondaryAction !== null && secondaryAction !== void 0 ? secondaryAction : null, primaryAction !== null && primaryAction !== void 0 ? primaryAction : null), import_react3.default.createElement("div", {
    className: "BannerActionsContainer",
    "data-primary-action": "leading"
  }, primaryAction !== null && primaryAction !== void 0 ? primaryAction : null, secondaryAction !== null && secondaryAction !== void 0 ? secondaryAction : null));
}
BannerActions.displayName = "BannerActions";
function BannerPrimaryAction({
  children,
  className,
  ...rest
}) {
  return import_react3.default.createElement(ButtonComponent, _extends({
    className: clsx_m_default("BannerPrimaryAction", className),
    variant: "default"
  }, rest), children);
}
BannerPrimaryAction.displayName = "BannerPrimaryAction";
function BannerSecondaryAction({
  children,
  className,
  ...rest
}) {
  return import_react3.default.createElement(ButtonComponent, _extends({
    className: clsx_m_default("BannerPrimaryAction", className),
    variant: "invisible"
  }, rest), children);
}
BannerSecondaryAction.displayName = "BannerSecondaryAction";

// node_modules/@primer/react/lib-esm/Banner/index.js
var Banner3 = Object.assign(Banner, {
  Title: BannerTitle,
  Description: BannerDescription,
  PrimaryAction: BannerPrimaryAction,
  SecondaryAction: BannerSecondaryAction
});

// node_modules/@primer/react/lib-esm/DataTable/DataTable.js
var import_react6 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/DataTable/useTable.js
var import_react4 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/DataTable/sorting.js
var SortDirection = {
  ASC: "ASC",
  DESC: "DESC",
  NONE: "NONE"
};
var DEFAULT_SORT_DIRECTION = SortDirection.ASC;
function transition(direction) {
  if (direction === SortDirection.ASC) {
    return SortDirection.DESC;
  }
  return SortDirection.ASC;
}
function basic(a, b) {
  return a === b ? 0 : a < b ? -1 : 1;
}
function datetime(a, b) {
  const timeA = a instanceof Date ? a.getTime() : a;
  const timeB = b instanceof Date ? b.getTime() : b;
  return timeA > timeB ? 1 : timeA < timeB ? -1 : 0;
}
function alphanumeric(inputA, inputB) {
  const groupsA = getAlphaNumericGroups(inputA);
  const groupsB = getAlphaNumericGroups(inputB);
  while (groupsA.length !== 0 && groupsB.length !== 0) {
    const a = groupsA.shift();
    const b = groupsB.shift();
    if (a === b) {
      continue;
    } else if (typeof a === "string" && typeof b === "string") {
      return a.localeCompare(b);
    } else if (typeof a === "number" && typeof b === "number") {
      return a > b ? 1 : -1;
    } else if (typeof a === "number" && typeof b === "string") {
      return -1;
    } else if (typeof a === "string" && typeof b === "number") {
      return 1;
    } else if (a === void 0 || b === void 0) {
      break;
    }
  }
  return groupsA.length > groupsB.length ? 1 : -1;
}
function getAlphaNumericGroups(input) {
  const groups = [];
  let i = 0;
  while (i < input.length) {
    let group = input[i];
    if (isNumeric(group)) {
      while (i + 1 < input.length && isNumeric(input[i + 1])) {
        group = group + input[i + 1];
        i++;
      }
      groups.push(parseInt(group, 10));
    } else {
      while (i + 1 < input.length && !isNumeric(input[i + 1])) {
        group = group + input[i + 1];
        i++;
      }
      groups.push(group);
    }
    i++;
  }
  return groups;
}
function isNumeric(value) {
  return !Number.isNaN(parseInt(value, 10));
}
var strategies = {
  alphanumeric,
  basic,
  datetime
};

// node_modules/@primer/react/lib-esm/DataTable/useTable.js
function useTable({
  columns,
  data,
  initialSortColumn,
  initialSortDirection
}) {
  const [rowOrder, setRowOrder] = (0, import_react4.useState)(data);
  const [prevData, setPrevData] = (0, import_react4.useState)(data);
  const [prevColumns, setPrevColumns] = (0, import_react4.useState)(columns);
  const [sortByColumn, setSortByColumn] = (0, import_react4.useState)(() => {
    return getInitialSortState(columns, initialSortColumn, initialSortDirection);
  });
  const {
    gridTemplateColumns
  } = useTableLayout(columns);
  if (columns !== prevColumns) {
    setPrevColumns(columns);
    if (sortByColumn) {
      const column = columns.find((column2) => {
        var _column$id;
        const id = (_column$id = column2.id) !== null && _column$id !== void 0 ? _column$id : column2.field;
        return sortByColumn.id === id;
      });
      if (!column) {
        setSortByColumn(null);
      }
    }
  }
  const headers = columns.map((column) => {
    var _column$id2;
    const id = (_column$id2 = column.id) !== null && _column$id2 !== void 0 ? _column$id2 : column.field;
    if (id === void 0) {
      throw new Error(`Expected either an \`id\` or \`field\` to be defined for a Column`);
    }
    const sortable = column.sortBy !== void 0 && column.sortBy !== false;
    return {
      id,
      column,
      isSortable() {
        return sortable;
      },
      getSortDirection() {
        if (sortByColumn && sortByColumn.id === id) {
          return sortByColumn.direction;
        }
        return SortDirection.NONE;
      }
    };
  });
  if (data !== prevData) {
    setPrevData(data);
    setRowOrder(data);
    if (sortByColumn) {
      sortRows(sortByColumn);
    }
  }
  function sortBy(header) {
    const sortState = {
      id: header.id,
      direction: sortByColumn && sortByColumn.id === header.id ? transition(sortByColumn.direction) : DEFAULT_SORT_DIRECTION
    };
    setSortByColumn(sortState);
    sortRows(sortState);
  }
  function sortRows(state) {
    const header = headers.find((header2) => {
      return header2.id === state.id;
    });
    if (!header) {
      throw new Error(`Unable to find header with id: ${state.id}`);
    }
    if (header.column.sortBy === false || header.column.sortBy === void 0) {
      throw new Error(`The column for this header is not sortable`);
    }
    const sortMethod = header.column.sortBy === true ? strategies.basic : typeof header.column.sortBy === "string" ? strategies[header.column.sortBy] : header.column.sortBy;
    setRowOrder((rowOrder2) => {
      return rowOrder2.slice().sort((a, b) => {
        if (header.column.field === void 0) {
          return 0;
        }
        if (typeof header.column.sortBy === "function") {
          if (state.direction === SortDirection.ASC) {
            return sortMethod(a, b);
          }
          return sortMethod(b, a);
        }
        const valueA = get2(a, header.column.field);
        const valueB = get2(b, header.column.field);
        if (valueA && valueB) {
          if (state.direction === SortDirection.ASC) {
            return sortMethod(valueA, valueB);
          }
          return sortMethod(valueB, valueA);
        }
        if (valueA) {
          return -1;
        }
        if (valueB) {
          return 1;
        }
        return 0;
      });
    });
  }
  return {
    headers,
    rows: rowOrder.map((row) => {
      return {
        id: `${row.id}`,
        getValue() {
          return row;
        },
        getCells() {
          return headers.map((header) => {
            var _header$column$rowHea;
            return {
              id: `${row.id}:${header.id}`,
              column: header.column,
              rowHeader: (_header$column$rowHea = header.column.rowHeader) !== null && _header$column$rowHea !== void 0 ? _header$column$rowHea : false,
              getValue() {
                if (header.column.field !== void 0) {
                  return get2(row, header.column.field);
                }
                throw new Error(`Unable to get value for column header ${header.id}`);
              }
            };
          });
        }
      };
    }),
    actions: {
      sortBy
    },
    gridTemplateColumns
  };
}
function getInitialSortState(columns, initialSortColumn, initialSortDirection) {
  if (initialSortColumn !== void 0) {
    const column = columns.find((column2) => {
      return column2.id === initialSortColumn || column2.field === initialSortColumn;
    });
    if (column === void 0) {
      if (true) {
        console.warn(`Warning: Unable to find a column with id or field set to: ${initialSortColumn}. Please provide a value to \`initialSortColumn\` which corresponds to a \`id\` or \`field\` value in a column.`);
      }
      return null;
    }
    if (column.sortBy === false || column.sortBy === void 0) {
      if (true) {
        console.warn(`Warning: The column specified by initialSortColumn={${initialSortColumn}} is not sortable. Please set \`sortBy\` to true or provide a sort strategy.`);
      }
      return null;
    }
    return {
      id: `${initialSortColumn}`,
      direction: initialSortDirection !== null && initialSortDirection !== void 0 ? initialSortDirection : DEFAULT_SORT_DIRECTION
    };
  }
  if (initialSortDirection !== void 0) {
    var _column$id3;
    const column = columns.find((column2) => {
      return column2.sortBy !== false && column2.sortBy !== void 0;
    });
    if (!column) {
      if (true) {
        console.warn(`Warning: An initialSortDirection value was provided but no columns are sortable. Please set \`sortBy\` to true or provide a sort strategy to a column.`);
      }
      return null;
    }
    const id = (_column$id3 = column.id) !== null && _column$id3 !== void 0 ? _column$id3 : column.field;
    if (id === void 0) {
      if (true) {
        console.warn(`Warning: Unable to find an \`id\` or \`field\` for the column: ${column}. Please set one of these properties on the column.`);
      }
      return null;
    }
    return {
      id,
      direction: initialSortDirection
    };
  }
  return null;
}
function useTableLayout(columns) {
  return {
    gridTemplateColumns: getGridTemplateFromColumns(columns).join(" ")
  };
}
function getGridTemplateFromColumns(columns) {
  return columns.map((column) => {
    var _column$width;
    const columnWidth = (_column$width = column.width) !== null && _column$width !== void 0 ? _column$width : "grow";
    let minWidth = "auto";
    let maxWidth = "1fr";
    if (columnWidth === "auto") {
      maxWidth = "auto";
    }
    if (columnWidth === "grow" && !column.maxWidth) {
      minWidth = "max-content";
    }
    if (columnWidth === "growCollapse") {
      minWidth = "0";
    }
    if (column.minWidth) {
      minWidth = typeof column.minWidth === "number" ? `${column.minWidth}px` : column.minWidth;
    }
    if (column.maxWidth) {
      maxWidth = typeof column.maxWidth === "number" ? `${column.maxWidth}px` : column.maxWidth;
    }
    if (typeof columnWidth !== "number" && ["grow", "growCollapse", "auto"].includes(columnWidth)) {
      return minWidth === maxWidth ? minWidth : `minmax(${minWidth}, ${maxWidth})`;
    }
    return typeof columnWidth === "number" ? `${columnWidth}px` : columnWidth;
  });
}
function get2(object, path) {
  return path.split(".").reduce((value, key) => {
    return value[key];
  }, object);
}

// node_modules/@primer/react/lib-esm/DataTable/Table.js
var import_react5 = __toESM(require_react());
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends2.apply(null, arguments);
}
var StyledTable = styled_components_browser_esm_default.table.withConfig({
  displayName: "Table__StyledTable",
  componentId: "sc-jofqvq-0"
})(["--table-border-radius:0.375rem;--table-cell-padding:var(--cell-padding-block,0.5rem) var(--cell-padding-inline,0.75rem);--table-font-size:0.75rem;background-color:", ";border-spacing:0;border-collapse:separate;display:grid;font-size:var(--table-font-size);grid-template-columns:var(--grid-template-columns);line-height:calc(20 / var(--table-font-size));width:100%;&[data-cell-padding='condensed']{--cell-padding-block:0.25rem;--cell-padding-inline:0.5rem;}&[data-cell-padding='normal']{--cell-padding-block:0.5rem;--cell-padding-inline:0.75rem;}&[data-cell-padding='spacious']{--cell-padding-block:0.75rem;--cell-padding-inline:1rem;}.TableCell:first-child,.TableHeader:first-child{border-left:1px solid ", ";}.TableCell:last-child,.TableHeader:last-child{border-right:1px solid ", ";}.TableHeader,.TableCell{text-align:start;display:flex;align-items:center;border-bottom:1px solid ", ";padding:var(--table-cell-padding);}.TableHeader[data-cell-align='end'],.TableCell[data-cell-align='end']{text-align:end;display:flex;justify-content:flex-end;}.TableHeader[data-cell-align='end'] .TableSortButton{display:flex;flex-direction:row-reverse;}.TableHead .TableRow:first-of-type .TableHeader{border-top:1px solid ", ";}.TableHead .TableRow:first-of-type .TableHeader:first-child{border-top-left-radius:var(--table-border-radius);}.TableHead .TableRow:first-of-type .TableHeader:last-child{border-top-right-radius:var(--table-border-radius);}.TableOverflowWrapper:last-child & .TableBody .TableRow:last-of-type .TableCell:first-child{border-bottom-left-radius:var(--table-border-radius);}.TableOverflowWrapper:last-child & .TableBody .TableRow:last-of-type .TableCell:last-child{border-bottom-right-radius:var(--table-border-radius);}.TableRow > *:first-child:not(.TableCellSkeleton),.TableRow > *:first-child .TableCellSkeletonItem{padding-inline-start:1rem;}.TableRow > *:last-child:not(.TableCellSkeleton),.TableRow > *:last-child .TableCellSkeletonItem{padding-inline-end:1rem;}.TableHeader{background-color:", ";color:", ";font-weight:600;border-top:1px solid ", ";}.TableHeader[aria-sort='descending'],.TableHeader[aria-sort='ascending']{color:", ";}.TableSortIcon{visibility:hidden;}.TableHeader:hover .TableSortIcon--ascending,.TableHeader .TableSortButton:focus .TableSortIcon--ascending{visibility:visible;}.TableHeader[aria-sort='ascending'] .TableSortIcon--ascending,.TableHeader[aria-sort='descending'] .TableSortIcon--descending{visibility:visible;}.TableRow:hover .TableCell:not(.TableCellSkeleton){background-color:", ";}.TableCell[scope='row']{align-items:center;display:flex;color:", ";font-weight:600;}.TableCellSkeleton{padding:0;}.TableCellSkeletonItems{display:flex;flex-direction:column;width:100%;}.TableCellSkeletonItem{padding:var(--table-cell-padding);&:nth-of-type(5n + 1){--skeleton-item-width:85%;}&:nth-of-type(5n + 2){--skeleton-item-width:67.5%;}&:nth-of-type(5n + 3){--skeleton-item-width:80%;}&:nth-of-type(5n + 4){--skeleton-item-width:60%;}&:nth-of-type(5n + 5){--skeleton-item-width:75%;}}.TableCellSkeletonItem [data-component='SkeletonText']{width:var(--skeleton-item-width);}.TableCellSkeletonItem:not(:last-of-type){border-bottom:1px solid ", ";}.TableHead,.TableBody,.TableRow{display:contents;}@supports (grid-template-columns:subgrid){.TableHead,.TableBody,.TableRow{display:grid;grid-template-columns:subgrid;grid-column:-1 /1;}}"], get("colors.canvas.default"), get("colors.border.default"), get("colors.border.default"), get("colors.border.default"), get("colors.border.default"), get("colors.canvas.subtle"), get("colors.fg.muted"), get("colors.border.default"), get("colors.fg.default"), get("colors.actionListItem.default.hoverBg"), get("colors.fg.default"), get("colors.border.default"));
var Table = import_react5.default.forwardRef(function Table2({
  "aria-labelledby": labelledby,
  cellPadding = "normal",
  className,
  gridTemplateColumns,
  ...rest
}, ref) {
  return (
    // TODO update type to be non-optional in next major release
    // @ts-expect-error this type should be required in the next major version
    import_react5.default.createElement(ScrollableRegion, {
      "aria-labelledby": labelledby,
      className: "TableOverflowWrapper"
    }, import_react5.default.createElement(StyledTable, _extends2({}, rest, {
      "aria-labelledby": labelledby,
      "data-cell-padding": cellPadding,
      className: clsx_m_default("Table", className),
      role: "table",
      ref,
      style: {
        "--grid-template-columns": gridTemplateColumns
      }
    })))
  );
});
function TableHead({
  children
}) {
  return (
    // We need to explicitly pass this role because some ATs and browsers drop table semantics
    // when we use `display: contents` or `display: grid` in the table
    import_react5.default.createElement("thead", {
      className: "TableHead",
      role: "rowgroup"
    }, children)
  );
}
TableHead.displayName = "TableHead";
function TableBody({
  children
}) {
  return (
    // We need to explicitly pass this role because some ATs and browsers drop table semantics
    // when we use `display: contents` or `display: grid` in the table
    import_react5.default.createElement("tbody", {
      className: "TableBody",
      role: "rowgroup"
    }, children)
  );
}
TableBody.displayName = "TableBody";
function TableHeader({
  align,
  children,
  ...rest
}) {
  return import_react5.default.createElement("th", _extends2({}, rest, {
    className: "TableHeader",
    role: "columnheader",
    scope: "col",
    "data-cell-align": align
  }), children);
}
TableHeader.displayName = "TableHeader";
function TableSortHeader({
  align,
  children,
  direction,
  onToggleSort,
  ...rest
}) {
  const ariaSort = direction === "DESC" ? "descending" : direction === "ASC" ? "ascending" : void 0;
  return import_react5.default.createElement(TableHeader, _extends2({}, rest, {
    "aria-sort": ariaSort,
    align
  }), import_react5.default.createElement(Button, {
    type: "button",
    className: "TableSortButton",
    onClick: () => {
      onToggleSort();
    }
  }, children, direction === SortDirection.NONE || direction === SortDirection.ASC ? import_react5.default.createElement(SortAscIcon, {
    className: "TableSortIcon TableSortIcon--ascending"
  }) : null, direction === SortDirection.DESC ? import_react5.default.createElement(SortDescIcon, {
    className: "TableSortIcon TableSortIcon--descending"
  }) : null));
}
TableSortHeader.displayName = "TableSortHeader";
function TableRow({
  children,
  ...rest
}) {
  return import_react5.default.createElement("tr", _extends2({}, rest, {
    className: "TableRow",
    role: "row"
  }), children);
}
TableRow.displayName = "TableRow";
function TableCell({
  align,
  className,
  children,
  scope,
  ...rest
}) {
  const BaseComponent = scope ? "th" : "td";
  const role = scope ? "rowheader" : "cell";
  return import_react5.default.createElement(BaseComponent, _extends2({}, rest, {
    className: clsx_m_default("TableCell", className),
    scope,
    role,
    "data-cell-align": align
  }), children);
}
TableCell.displayName = "TableCell";
function TableCellPlaceholder({
  children
}) {
  return import_react5.default.createElement(Text, {
    color: "fg.subtle"
  }, children);
}
TableCellPlaceholder.displayName = "TableCellPlaceholder";
var StyledTableContainer = styled_components_browser_esm_default.div.withConfig({
  displayName: "Table__StyledTableContainer",
  componentId: "sc-jofqvq-1"
})(["display:grid;grid-template-columns:1fr 1fr;grid-template-areas:'title actions' 'divider divider' 'subtitle subtitle' 'filter filter' 'table table' 'footer footer';column-gap:", ";", " .TableTitle{grid-area:title;align-self:center;}.TableSubtitle{grid-area:subtitle;}.TableActions{display:flex;column-gap:", ";align-items:center;grid-area:actions;justify-self:end;}.TableDivider{grid-area:divider;margin-top:", ";margin-bottom:", ";}.Table{grid-area:table;}.TableTitle + .TableOverflowWrapper,.TableSubtitle + .TableOverflowWrapper,.TableActions + .TableOverflowWrapper{margin-top:", ";}.TableOverflowWrapper{grid-area:table;}"], get("space.2"), sx, get("space.2"), get("space.3"), get("space.2"), get("space.2"));
function TableContainer({
  children,
  sx: sx2
}) {
  return import_react5.default.createElement(StyledTableContainer, {
    sx: sx2
  }, children);
}
TableContainer.displayName = "TableContainer";
var TableTitle = import_react5.default.forwardRef(function TableTitle2({
  as = "h2",
  children,
  id
}, ref) {
  return import_react5.default.createElement(Box, {
    as,
    className: "TableTitle",
    id,
    ref,
    sx: {
      color: "fg.default",
      fontWeight: "bold",
      fontSize: 1,
      lineHeight: "calc(20 / 14)",
      margin: 0
    }
  }, children);
});
function TableSubtitle({
  as,
  children,
  id
}) {
  return import_react5.default.createElement(Box, {
    as,
    className: "TableSubtitle",
    id,
    sx: {
      color: "fg.default",
      fontWeight: "normal",
      fontSize: 0,
      lineHeight: "default",
      margin: 0
    }
  }, children);
}
TableSubtitle.displayName = "TableSubtitle";
function TableDivider() {
  return import_react5.default.createElement(Box, {
    className: "TableDivider",
    role: "presentation",
    sx: {
      backgroundColor: "border.default",
      width: "100%",
      height: 1
    }
  });
}
TableDivider.displayName = "TableDivider";
function TableActions({
  children
}) {
  return import_react5.default.createElement("div", {
    className: "TableActions"
  }, children);
}
TableActions.displayName = "TableActions";
function TableSkeleton({
  cellPadding,
  columns,
  rows = 10,
  ...rest
}) {
  const {
    gridTemplateColumns
  } = useTableLayout(columns);
  return import_react5.default.createElement(Table, _extends2({}, rest, {
    cellPadding,
    gridTemplateColumns
  }), import_react5.default.createElement(TableHead, null, import_react5.default.createElement(TableRow, null, Array.isArray(columns) ? columns.map((column, i) => {
    return import_react5.default.createElement(TableHeader, {
      key: i
    }, typeof column.header === "string" ? column.header : column.header());
  }) : null)), import_react5.default.createElement(TableBody, null, import_react5.default.createElement(TableRow, null, Array.from({
    length: columns.length
  }).map((_, i) => {
    return import_react5.default.createElement(TableCell, {
      key: i,
      className: "TableCellSkeleton"
    }, import_react5.default.createElement(VisuallyHidden2, null, "Loading"), import_react5.default.createElement("div", {
      className: "TableCellSkeletonItems"
    }, Array.from({
      length: rows
    }).map((_2, i2) => {
      return import_react5.default.createElement("div", {
        key: i2,
        className: "TableCellSkeletonItem"
      }, import_react5.default.createElement(SkeletonText, null));
    })));
  }))));
}
TableSkeleton.displayName = "TableSkeleton";
var Button = styled_components_browser_esm_default.button.withConfig({
  displayName: "Table__Button",
  componentId: "sc-jofqvq-2"
})(["padding:0;border:0;margin:0;display:inline-flex;padding:0;border:0;appearance:none;background:none;cursor:pointer;text-align:start;font:inherit;color:inherit;column-gap:0.5rem;align-items:center;&::-moz-focus-inner{border:0;}"]);

// node_modules/@primer/react/lib-esm/DataTable/DataTable.js
function DataTable({
  "aria-labelledby": labelledby,
  "aria-describedby": describedby,
  cellPadding,
  columns,
  data,
  initialSortColumn,
  initialSortDirection
}) {
  const {
    headers,
    rows,
    actions,
    gridTemplateColumns
  } = useTable({
    data,
    columns,
    initialSortColumn,
    initialSortDirection
  });
  return import_react6.default.createElement(Table, {
    "aria-labelledby": labelledby,
    "aria-describedby": describedby,
    cellPadding,
    gridTemplateColumns
  }, import_react6.default.createElement(TableHead, null, import_react6.default.createElement(TableRow, null, headers.map((header) => {
    if (header.isSortable()) {
      return import_react6.default.createElement(TableSortHeader, {
        key: header.id,
        align: header.column.align,
        direction: header.getSortDirection(),
        onToggleSort: () => {
          actions.sortBy(header);
        }
      }, typeof header.column.header === "string" ? header.column.header : header.column.header());
    }
    return import_react6.default.createElement(TableHeader, {
      key: header.id,
      align: header.column.align
    }, typeof header.column.header === "string" ? header.column.header : header.column.header());
  }))), import_react6.default.createElement(TableBody, null, rows.map((row) => {
    return import_react6.default.createElement(TableRow, {
      key: row.id
    }, row.getCells().map((cell) => {
      return import_react6.default.createElement(TableCell, {
        key: cell.id,
        scope: cell.rowHeader ? "row" : void 0,
        align: cell.column.align
      }, cell.column.renderCell ? cell.column.renderCell(row.getValue()) : cell.getValue());
    }));
  })));
}
DataTable.displayName = "DataTable";

// node_modules/@primer/react/lib-esm/DataTable/ErrorDialog.js
var import_react7 = __toESM(require_react());
function ErrorDialog({
  title = "Error",
  children,
  onRetry,
  onDismiss
}) {
  return import_react7.default.createElement(ConfirmationDialog, {
    title,
    onClose: (gesture) => {
      if (gesture === "confirm") {
        onRetry === null || onRetry === void 0 ? void 0 : onRetry();
      } else {
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
      }
    },
    confirmButtonContent: "Retry",
    cancelButtonContent: "Dismiss"
  }, children);
}
ErrorDialog.displayName = "ErrorDialog";

// node_modules/@primer/react/lib-esm/DataTable/Pagination.js
var import_react8 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/internal/components/ButtonReset.js
var Button2 = styled_components_browser_esm_default.button.withConfig({
  displayName: "ButtonReset__Button",
  componentId: "sc-1yqlmwf-0"
})(["padding:0;border:0;margin:0;display:inline-flex;padding:0;border:0;appearance:none;background:none;cursor:pointer;text-align:start;font:inherit;color:inherit;align-items:center;&::-moz-focus-inner{border:0;}", ""], sx);

// node_modules/@primer/react/lib-esm/DataTable/Pagination.js
var StyledPagination = styled_components_browser_esm_default.nav.withConfig({
  displayName: "Pagination__StyledPagination",
  componentId: "sc-1auq45q-0"
})(
  ["display:flex;align-items:center;justify-content:space-between;column-gap:1rem;width:100%;grid-area:footer;padding:0.5rem 1rem;border:1px solid ", ";border-top-width:0;border-end-start-radius:6px;border-end-end-radius:6px;.TablePaginationRange{color:", ";font-size:0.75rem;margin:0;}.TablePaginationSteps{display:flex;align-items:center;flex-wrap:wrap;list-style:none;color:", ";font-size:0.875rem;margin:0;padding:0;}.TablePaginationStep:first-of-type{margin-right:1rem;}.TablePaginationStep:last-of-type{margin-left:1rem;}.TablePaginationAction{display:flex;align-items:center;color:", ";font-size:0.875rem;line-height:calc(20 / 14);user-select:none;padding:0.5rem;border-radius:6px;}.TablePaginationAction[data-has-page]{color:", ";}.TablePaginationPage{min-width:2rem;min-height:2rem;display:flex;align-items:center;justify-content:center;font-size:0.875rem;line-height:calc(20 / 14);user-select:none;border-radius:6px;}.TablePaginationAction[data-has-page]:hover,.TablePaginationAction[data-has-page]:focus,.TablePaginationPage:hover,.TablePaginationPage:focus{background-color:", ";transition-duration:0.1s;}.TablePaginationPage[data-active='true']{background-color:", ";color:", ";}.TablePaginationTruncationStep{display:flex;align-items:center;justify-content:center;min-width:2rem;min-height:2rem;user-select:none;}", ""],
  get("colors.border.default"),
  get("colors.fg.muted"),
  get("colors.fg.default"),
  get("colors.fg.muted"),
  get("colors.accent.fg"),
  get("colors.actionListItem.default.hoverBg"),
  get("colors.accent.emphasis"),
  get("colors.fg.onEmphasis"),
  // Hides pages based on the viewport range passed to `showPages`
  Object.keys(viewportRanges).map((viewportRangeKey) => {
    return `
      @media (${viewportRanges[viewportRangeKey]}) {
        .TablePaginationSteps[data-hidden-viewport-ranges*='${viewportRangeKey}'] > *:not(:first-child):not(:last-child) {
          display: none;
        }

        .TablePaginationSteps[data-hidden-viewport-ranges*='${viewportRangeKey}'] > *:first-child {
          margin-inline-end: 0;
        }

        .TablePaginationSteps[data-hidden-viewport-ranges*='${viewportRangeKey}'] > *:last-child {
          margin-inline-start: 0;
        }
      }
    `;
  }).join("")
);
var MAX_TRUNCATED_STEP_COUNT = 7;
function Pagination({
  "aria-label": label,
  defaultPageIndex,
  id,
  onChange,
  pageSize = 25,
  showPages = {
    narrow: false
  },
  totalCount
}) {
  const {
    pageIndex,
    pageStart,
    pageEnd,
    pageCount,
    hasPreviousPage,
    hasNextPage,
    selectPage,
    selectNextPage,
    selectPreviousPage
  } = usePagination({
    defaultPageIndex,
    onChange,
    pageSize,
    totalCount
  });
  const truncatedPageCount = pageCount > 2 ? Math.min(pageCount - 2, MAX_TRUNCATED_STEP_COUNT) : 0;
  const [offsetStartIndex, setOffsetStartIndex] = (0, import_react8.useState)(() => {
    return getDefaultOffsetStartIndex(pageIndex, pageCount, truncatedPageCount);
  });
  const offsetEndIndex = offsetStartIndex + truncatedPageCount - 1;
  const hasLeadingTruncation = offsetStartIndex >= 2;
  const hasTrailingTruncation = pageCount - 1 - offsetEndIndex > 1;
  const getViewportRangesToHidePages = (0, import_react8.useCallback)(() => {
    if (typeof showPages !== "boolean") {
      return Object.keys(showPages).filter((key) => !showPages[key]);
    }
    if (showPages) {
      return [];
    } else {
      return Object.keys(viewportRanges);
    }
  }, [showPages]);
  return import_react8.default.createElement(LiveRegion, null, import_react8.default.createElement(LiveRegionOutlet, null), import_react8.default.createElement(StyledPagination, {
    "aria-label": label,
    className: "TablePagination",
    id
  }, import_react8.default.createElement(Range, {
    pageStart,
    pageEnd,
    totalCount
  }), import_react8.default.createElement("ol", {
    className: "TablePaginationSteps",
    "data-hidden-viewport-ranges": getViewportRangesToHidePages().join(" ")
  }, import_react8.default.createElement(Step, null, import_react8.default.createElement(Button2, {
    className: "TablePaginationAction",
    type: "button",
    "data-has-page": hasPreviousPage ? true : void 0,
    "aria-disabled": !hasPreviousPage ? true : void 0,
    onClick: () => {
      if (!hasPreviousPage) {
        return;
      }
      selectPreviousPage();
      if (hasLeadingTruncation) {
        if (pageIndex - 1 < offsetStartIndex + 1) {
          setOffsetStartIndex(offsetStartIndex - 1);
        }
      }
    }
  }, hasPreviousPage ? import_react8.default.createElement(ChevronLeftIcon, null) : null, import_react8.default.createElement("span", {
    className: "TablePaginationActionLabel"
  }, "Previous"), import_react8.default.createElement(VisuallyHidden, null, "page"))), pageCount > 0 ? import_react8.default.createElement(Step, null, import_react8.default.createElement(Page, {
    active: pageIndex === 0,
    onClick: () => {
      selectPage(0);
      if (pageCount > 1) {
        setOffsetStartIndex(1);
      }
    }
  }, 1, hasLeadingTruncation ? import_react8.default.createElement(VisuallyHidden, null, "") : null)) : null, pageCount > 2 ? Array.from({
    length: truncatedPageCount
  }).map((_, i) => {
    if (i === 0 && hasLeadingTruncation) {
      return import_react8.default.createElement(TruncationStep, {
        key: `truncation-${i}`
      });
    }
    if (i === truncatedPageCount - 1 && hasTrailingTruncation) {
      return import_react8.default.createElement(TruncationStep, {
        key: `truncation-${i}`
      });
    }
    const page = offsetStartIndex + i;
    return import_react8.default.createElement(Step, {
      key: i
    }, import_react8.default.createElement(Page, {
      active: pageIndex === page,
      onClick: () => {
        selectPage(page);
      }
    }, page + 1, i === truncatedPageCount - 2 && hasTrailingTruncation ? import_react8.default.createElement(VisuallyHidden, null, "") : null));
  }) : null, pageCount > 1 ? import_react8.default.createElement(Step, null, import_react8.default.createElement(Page, {
    active: pageIndex === pageCount - 1,
    onClick: () => {
      selectPage(pageCount - 1);
      setOffsetStartIndex(pageCount - 1 - truncatedPageCount);
    }
  }, pageCount)) : null, import_react8.default.createElement(Step, null, import_react8.default.createElement(Button2, {
    className: "TablePaginationAction",
    type: "button",
    "data-has-page": hasNextPage ? true : void 0,
    "aria-disabled": !hasNextPage ? true : void 0,
    onClick: () => {
      if (!hasNextPage) {
        return;
      }
      selectNextPage();
      if (hasTrailingTruncation) {
        if (pageIndex + 1 > offsetEndIndex - 1) {
          setOffsetStartIndex(offsetStartIndex + 1);
        }
      }
    }
  }, import_react8.default.createElement("span", {
    className: "TablePaginationActionLabel"
  }, "Next"), import_react8.default.createElement(VisuallyHidden, null, "page"), hasNextPage ? import_react8.default.createElement(ChevronRightIcon, null) : null)))));
}
Pagination.displayName = "Pagination";
function getDefaultOffsetStartIndex(pageIndex, pageCount, truncatedPageCount) {
  if (pageIndex > pageCount - 1 - pageIndex) {
    if (pageCount - 1 - pageIndex >= truncatedPageCount) {
      return pageIndex - 3;
    }
    return pageCount - 1 - truncatedPageCount;
  }
  if (pageIndex < pageCount - 1 - pageIndex) {
    if (pageIndex >= truncatedPageCount) {
      return pageIndex - 3;
    }
    return 1;
  }
  if (pageIndex < truncatedPageCount) {
    return pageIndex;
  }
  return pageIndex - 3;
}
function Range({
  pageStart,
  pageEnd,
  totalCount
}) {
  const start = pageStart + 1;
  const end = pageEnd === totalCount - 1 ? totalCount : pageEnd;
  return import_react8.default.createElement(import_react8.default.Fragment, null, import_react8.default.createElement(Message, {
    value: `Showing ${start} through ${end} of ${totalCount}`
  }), import_react8.default.createElement("p", {
    className: "TablePaginationRange"
  }, start, import_react8.default.createElement(VisuallyHidden, {
    as: "span"
  }, "through"), import_react8.default.createElement("span", {
    "aria-hidden": "true"
  }, ""), end, " of ", totalCount));
}
function TruncationStep() {
  return import_react8.default.createElement("li", {
    "aria-hidden": "true",
    className: "TablePaginationTruncationStep"
  }, "");
}
TruncationStep.displayName = "TruncationStep";
function Step({
  children
}) {
  return import_react8.default.createElement("li", {
    className: "TablePaginationStep"
  }, children);
}
Step.displayName = "Step";
function Page({
  active,
  children,
  onClick
}) {
  return import_react8.default.createElement(Button2, {
    className: "TablePaginationPage",
    type: "button",
    "data-active": active ? true : void 0,
    "aria-current": active ? true : void 0,
    onClick
  }, import_react8.default.createElement(VisuallyHidden, null, "Page"), children);
}
Page.displayName = "Page";
function usePagination(config) {
  const {
    defaultPageIndex,
    onChange,
    pageSize,
    totalCount
  } = config;
  const pageCount = Math.ceil(totalCount / pageSize);
  const [pageIndex, setPageIndex] = (0, import_react8.useState)(() => {
    if (defaultPageIndex !== void 0) {
      if (defaultPageIndex >= 0 && defaultPageIndex < pageCount) {
        return defaultPageIndex;
      }
      true ? warning(
        true,
        // eslint-disable-next-line github/unescaped-html-literal
        "<Pagination> expected `defaultPageIndex` to be less than the total number of pages. Instead, received a `defaultPageIndex` of %s with %s total pages.",
        defaultPageIndex,
        pageCount
      ) : void 0;
    }
    return 0;
  });
  const pageStart = pageIndex * pageSize;
  const pageEnd = Math.min(pageIndex * pageSize + pageSize, totalCount - 1);
  const hasNextPage = pageIndex + 1 < pageCount;
  const hasPreviousPage = pageIndex > 0;
  function selectPage(newPageIndex) {
    if (pageIndex !== newPageIndex) {
      setPageIndex(newPageIndex);
      onChange === null || onChange === void 0 ? void 0 : onChange({
        pageIndex: newPageIndex
      });
    }
  }
  function selectPreviousPage() {
    if (hasPreviousPage) {
      selectPage(pageIndex - 1);
    }
  }
  function selectNextPage() {
    if (hasNextPage) {
      selectPage(pageIndex + 1);
    }
  }
  return {
    pageIndex,
    pageStart,
    pageEnd,
    pageCount,
    hasNextPage,
    hasPreviousPage,
    selectPage,
    selectPreviousPage,
    selectNextPage
  };
}

// node_modules/@primer/react/lib-esm/DataTable/index.js
var Table3 = Object.assign(Table, {
  Container: TableContainer,
  Title: TableTitle,
  Subtitle: TableSubtitle,
  Actions: TableActions,
  Divider: TableDivider,
  Skeleton: TableSkeleton,
  Head: TableHead,
  Body: TableBody,
  Header: TableHeader,
  Row: TableRow,
  Cell: TableCell,
  CellPlaceholder: TableCellPlaceholder,
  Pagination,
  ErrorDialog
});

// node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/InlineAutocomplete.js
var import_react13 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/hooks/useSyntheticChange.js
var import_react9 = __toESM(require_react());
var calculateNewCaretPosition = (originalCaretPosition, replaceRange, insertLength) => {
  const deleteLength = replaceRange[1] - replaceRange[0];
  const lengthDifference = insertLength - deleteLength;
  return originalCaretPosition < replaceRange[0] ? originalCaretPosition : originalCaretPosition < replaceRange[1] ? replaceRange[0] + insertLength : originalCaretPosition + lengthDifference;
};
var SyntheticChangeEvent = (dispatchedEvent, target) => ({
  // Spreading the event is particularly imperfect. Functions called on the `SyntheticEvent`
  // will have the wrong `this` binding and shallow object properties may fall out of sync.
  // We consider this acceptable since this is only the fallback behavior, but it's not ideal by any means.
  ...dispatchedEvent,
  nativeEvent: dispatchedEvent,
  target,
  // `currentTarget` is the element that the event listener is attached to. The event
  // doesn't know this, so `event.currentTarget` is `null`.
  currentTarget: target,
  preventDefault: () => dispatchedEvent.preventDefault(),
  isDefaultPrevented: () => dispatchedEvent.defaultPrevented,
  // This event doesn't bubble anyway so there's no need for the consumer to try to
  // stop propagation
  isPropagationStopped: () => false,
  // "As of v17, e.persist() doesnt do anything because the SyntheticEvent is no
  // longer pooled" -  https://reactjs.org/docs/events.html#overview
  persist: () => ({
    /* noop */
  })
});
var useSyntheticChange = ({
  inputRef,
  fallbackEventHandler
}) => (0, import_react9.useCallback)((insertValue, replaceRange_, newSelection_) => {
  var _input$selectionStart, _input$selectionEnd, _input$selectionStart2;
  const input = inputRef.current;
  if (!input) return;
  input.focus();
  const replaceRange = replaceRange_ !== null && replaceRange_ !== void 0 ? replaceRange_ : [(_input$selectionStart = input.selectionStart) !== null && _input$selectionStart !== void 0 ? _input$selectionStart : input.value.length, (_input$selectionEnd = input.selectionEnd) !== null && _input$selectionEnd !== void 0 ? _input$selectionEnd : input.value.length];
  const newSelectionStart = newSelection_ === void 0 ? calculateNewCaretPosition((_input$selectionStart2 = input.selectionStart) !== null && _input$selectionStart2 !== void 0 ? _input$selectionStart2 : input.value.length, replaceRange, insertValue.length) : Array.isArray(newSelection_) ? newSelection_[0] : newSelection_;
  const newSelectionEnd = Array.isArray(newSelection_) ? newSelection_[1] : newSelectionStart;
  let execCommandResult = false;
  try {
    if (document.activeElement !== input) throw new Error("Input must be focused to use execCommand");
    input.setSelectionRange(replaceRange[0], replaceRange[1]);
    execCommandResult = insertValue === "" ? document.execCommand("delete", false) : document.execCommand("insertText", false, insertValue);
    input.setSelectionRange(newSelectionStart, newSelectionEnd);
  } catch (e) {
    execCommandResult = false;
  }
  if (!execCommandResult) {
    const newValue = input.value.slice(0, replaceRange[0]) + insertValue + input.value.slice(replaceRange[1]);
    const event = new InputEvent("input", {
      bubbles: false
    });
    inputRef.current.value = newValue;
    inputRef.current.setSelectionRange(newSelectionStart, newSelectionEnd);
    inputRef.current.dispatchEvent(event);
    fallbackEventHandler(SyntheticChangeEvent(event, inputRef.current));
  }
}, [inputRef, fallbackEventHandler]);

// node_modules/@primer/react/lib-esm/drafts/utils/character-coordinates.js
var propertiesToCopy = [
  "direction",
  // RTL support
  "boxSizing",
  "width",
  // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does
  "height",
  "overflowX",
  "overflowY",
  // copy the scrollbar for IE
  "borderTopWidth",
  "borderRightWidth",
  "borderBottomWidth",
  "borderLeftWidth",
  "borderStyle",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  // https://developer.mozilla.org/en-US/docs/Web/CSS/font
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "fontStretch",
  "fontSize",
  "fontSizeAdjust",
  "lineHeight",
  "fontFamily",
  "textAlign",
  "textTransform",
  "textIndent",
  "textDecoration",
  // might not make a difference, but better be safe
  "letterSpacing",
  "wordSpacing",
  "tabSize",
  "MozTabSize"
  // prefixed version for Firefox <= 52
];
function getCharacterCoordinates(element, index) {
  const isFirefox = "mozInnerScreenX" in window;
  const div = document.createElement("div");
  div.id = "input-textarea-caret-position-mirror-div";
  document.body.appendChild(div);
  const style = div.style;
  const computed = window.getComputedStyle(element);
  const lineHeight = isNaN(parseInt(computed.lineHeight)) ? parseInt(computed.fontSize) * 1.2 : parseInt(computed.lineHeight);
  const isInput = element instanceof HTMLInputElement;
  style.whiteSpace = isInput ? "nowrap" : "pre-wrap";
  style.wordWrap = isInput ? "" : "break-word";
  style.position = "absolute";
  for (const prop of propertiesToCopy) {
    if (isInput && prop === "lineHeight") {
      if (computed.boxSizing === "border-box") {
        const height = parseInt(computed.height);
        const outerHeight = parseInt(computed.paddingTop) + parseInt(computed.paddingBottom) + parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth);
        const targetHeight = outerHeight + lineHeight;
        if (height > targetHeight) {
          style.lineHeight = `${height - outerHeight}px`;
        } else if (height === targetHeight) {
          style.lineHeight = computed.lineHeight;
        } else {
          style.lineHeight = "0";
        }
      } else {
        style.lineHeight = computed.height;
      }
    } else if (!isInput && prop === "width" && computed.boxSizing === "border-box") {
      const totalBorderWidth = parseFloat(computed.borderLeftWidth) + parseFloat(computed.borderRightWidth);
      const width = isFirefox ? parseFloat(computed.width) - totalBorderWidth : element.clientWidth + totalBorderWidth;
      style.width = `${width}px`;
    } else {
      style[prop] = computed[prop];
    }
  }
  if (isFirefox) {
    if (element.scrollHeight > parseInt(computed.height)) style.overflowY = "scroll";
  } else {
    style.overflow = "hidden";
  }
  div.textContent = element.value.substring(0, index);
  if (isInput) div.textContent = div.textContent.replace(/\s/g, "");
  const span = document.createElement("span");
  span.textContent = isInput ? "." : element.value.substring(index) || ".";
  div.appendChild(span);
  const coordinates = {
    top: span.offsetTop + parseInt(computed.borderTopWidth),
    left: span.offsetLeft + parseInt(computed.borderLeftWidth),
    height: lineHeight
  };
  document.body.removeChild(div);
  return coordinates;
}
var getScrollAdjustedCharacterCoordinates = (input, index) => {
  const {
    height,
    top,
    left
  } = getCharacterCoordinates(input, index);
  return {
    height,
    top: top - input.scrollTop,
    left: left - input.scrollLeft
  };
};
var getAbsoluteCharacterCoordinates = (input, index) => {
  const {
    top: relativeTop,
    left: relativeLeft,
    height
  } = getScrollAdjustedCharacterCoordinates(input, index);
  const {
    top: viewportOffsetTop,
    left: viewportOffsetLeft
  } = input.getBoundingClientRect();
  return {
    height,
    top: viewportOffsetTop + relativeTop,
    left: viewportOffsetLeft + relativeLeft
  };
};

// node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/utils.js
var import_react10 = __toESM(require_react());
var singleWordTriggerTerminators = /* @__PURE__ */ new Set([" ", "\n"]);
var multiWordTriggerTerminators = /* @__PURE__ */ new Set([".", "\n"]);
var isWhitespace = (char) => /\s/.test(char);
var calculateSuggestionsQuery = (triggers, text, caretLocation) => {
  for (let i = caretLocation - 1, query = "", potentialTriggers = triggers; i >= 0 && potentialTriggers.length > 0; i--) {
    const character = text[i];
    if (singleWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter((t) => t.multiWord);
    if (multiWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter((t) => !t.multiWord);
    for (const trigger4 of potentialTriggers.filter((t) => character === t.triggerChar)) {
      if ((i === 0 || isWhitespace(text[i - 1])) && !isWhitespace(query[0])) return {
        trigger: trigger4,
        query
      };
      potentialTriggers = potentialTriggers.filter((t) => t !== trigger4);
    }
    query = character + query;
  }
  return null;
};
var getSuggestionValue = (suggestion) => typeof suggestion === "string" ? suggestion : suggestion.value;
var getSuggestionKey = (suggestion) => {
  var _suggestion$key;
  return typeof suggestion === "string" ? suggestion : (_suggestion$key = suggestion.key) !== null && _suggestion$key !== void 0 ? _suggestion$key : suggestion.value;
};
function requireChildrenToBeInput(child, childRef) {
  import_react10.Children.only(child);
  if (
    // There is no way to know what type the underlying child is until it mounts, so this
    // will always pass on first render before failing on the second render
    childRef.current && !(childRef.current instanceof HTMLInputElement) && !(childRef.current instanceof HTMLTextAreaElement)
  ) {
    throw new TypeError(`AutocompleteTextarea child must be a component that forwards a ref and props to an <input> or <textarea> element.`);
  }
  return child;
}
var augmentHandler = (...handlers) => (event) => {
  for (const handler of [...handlers].reverse()) {
    if (!event.isDefaultPrevented()) handler === null || handler === void 0 ? void 0 : handler(event);
  }
};

// node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/_AutocompleteSuggestions.js
var import_react12 = __toESM(require_react());

// node_modules/@github/combobox-nav/dist/index.js
var Combobox = class {
  constructor(input, list, { tabInsertsSuggestions, defaultFirstOption, scrollIntoViewOptions } = {}) {
    this.input = input;
    this.list = list;
    this.tabInsertsSuggestions = tabInsertsSuggestions !== null && tabInsertsSuggestions !== void 0 ? tabInsertsSuggestions : true;
    this.defaultFirstOption = defaultFirstOption !== null && defaultFirstOption !== void 0 ? defaultFirstOption : false;
    this.scrollIntoViewOptions = scrollIntoViewOptions !== null && scrollIntoViewOptions !== void 0 ? scrollIntoViewOptions : { block: "nearest", inline: "nearest" };
    this.isComposing = false;
    if (!list.id) {
      list.id = `combobox-${Math.random().toString().slice(2, 6)}`;
    }
    this.ctrlBindings = !!navigator.userAgent.match(/Macintosh/);
    this.keyboardEventHandler = (event) => keyboardBindings(event, this);
    this.compositionEventHandler = (event) => trackComposition(event, this);
    this.inputHandler = this.clearSelection.bind(this);
    input.setAttribute("role", "combobox");
    input.setAttribute("aria-controls", list.id);
    input.setAttribute("aria-expanded", "false");
    input.setAttribute("aria-autocomplete", "list");
    input.setAttribute("aria-haspopup", "listbox");
  }
  destroy() {
    this.clearSelection();
    this.stop();
    this.input.removeAttribute("role");
    this.input.removeAttribute("aria-controls");
    this.input.removeAttribute("aria-expanded");
    this.input.removeAttribute("aria-autocomplete");
    this.input.removeAttribute("aria-haspopup");
  }
  start() {
    this.input.setAttribute("aria-expanded", "true");
    this.input.addEventListener("compositionstart", this.compositionEventHandler);
    this.input.addEventListener("compositionend", this.compositionEventHandler);
    this.input.addEventListener("input", this.inputHandler);
    this.input.addEventListener("keydown", this.keyboardEventHandler);
    this.list.addEventListener("click", commitWithElement);
    this.indicateDefaultOption();
  }
  stop() {
    this.clearSelection();
    this.input.setAttribute("aria-expanded", "false");
    this.input.removeEventListener("compositionstart", this.compositionEventHandler);
    this.input.removeEventListener("compositionend", this.compositionEventHandler);
    this.input.removeEventListener("input", this.inputHandler);
    this.input.removeEventListener("keydown", this.keyboardEventHandler);
    this.list.removeEventListener("click", commitWithElement);
  }
  indicateDefaultOption() {
    var _a2;
    if (this.defaultFirstOption) {
      (_a2 = Array.from(this.list.querySelectorAll('[role="option"]:not([aria-disabled="true"])')).filter(visible)[0]) === null || _a2 === void 0 ? void 0 : _a2.setAttribute("data-combobox-option-default", "true");
    }
  }
  navigate(indexDiff = 1) {
    const focusEl = Array.from(this.list.querySelectorAll('[aria-selected="true"]')).filter(visible)[0];
    const els = Array.from(this.list.querySelectorAll('[role="option"]')).filter(visible);
    const focusIndex = els.indexOf(focusEl);
    if (focusIndex === els.length - 1 && indexDiff === 1 || focusIndex === 0 && indexDiff === -1) {
      this.clearSelection();
      this.input.focus();
      return;
    }
    let indexOfItem = indexDiff === 1 ? 0 : els.length - 1;
    if (focusEl && focusIndex >= 0) {
      const newIndex = focusIndex + indexDiff;
      if (newIndex >= 0 && newIndex < els.length)
        indexOfItem = newIndex;
    }
    const target = els[indexOfItem];
    if (!target)
      return;
    for (const el of els) {
      el.removeAttribute("data-combobox-option-default");
      if (target === el) {
        this.input.setAttribute("aria-activedescendant", target.id);
        target.setAttribute("aria-selected", "true");
        fireSelectEvent(target);
        target.scrollIntoView(this.scrollIntoViewOptions);
      } else {
        el.removeAttribute("aria-selected");
      }
    }
  }
  clearSelection() {
    this.input.removeAttribute("aria-activedescendant");
    for (const el of this.list.querySelectorAll('[aria-selected="true"]')) {
      el.removeAttribute("aria-selected");
    }
    this.indicateDefaultOption();
  }
};
function keyboardBindings(event, combobox) {
  if (event.shiftKey || event.metaKey || event.altKey)
    return;
  if (!combobox.ctrlBindings && event.ctrlKey)
    return;
  if (combobox.isComposing)
    return;
  switch (event.key) {
    case "Enter":
      if (commit(combobox.input, combobox.list)) {
        event.preventDefault();
      }
      break;
    case "Tab":
      if (combobox.tabInsertsSuggestions && commit(combobox.input, combobox.list)) {
        event.preventDefault();
      }
      break;
    case "Escape":
      combobox.clearSelection();
      break;
    case "ArrowDown":
      combobox.navigate(1);
      event.preventDefault();
      break;
    case "ArrowUp":
      combobox.navigate(-1);
      event.preventDefault();
      break;
    case "n":
      if (combobox.ctrlBindings && event.ctrlKey) {
        combobox.navigate(1);
        event.preventDefault();
      }
      break;
    case "p":
      if (combobox.ctrlBindings && event.ctrlKey) {
        combobox.navigate(-1);
        event.preventDefault();
      }
      break;
    default:
      if (event.ctrlKey)
        break;
      combobox.clearSelection();
  }
}
function commitWithElement(event) {
  if (!(event.target instanceof Element))
    return;
  const target = event.target.closest('[role="option"]');
  if (!target)
    return;
  if (target.getAttribute("aria-disabled") === "true")
    return;
  fireCommitEvent(target, { event });
}
function commit(input, list) {
  const target = list.querySelector('[aria-selected="true"], [data-combobox-option-default="true"]');
  if (!target)
    return false;
  if (target.getAttribute("aria-disabled") === "true")
    return true;
  target.click();
  return true;
}
function fireCommitEvent(target, detail) {
  target.dispatchEvent(new CustomEvent("combobox-commit", { bubbles: true, detail }));
}
function fireSelectEvent(target) {
  target.dispatchEvent(new Event("combobox-select", { bubbles: true }));
}
function visible(el) {
  return !el.hidden && !(el instanceof HTMLInputElement && el.type === "hidden") && (el.offsetWidth > 0 || el.offsetHeight > 0);
}
function trackComposition(event, combobox) {
  combobox.isComposing = event.type === "compositionstart";
  const list = document.getElementById(combobox.input.getAttribute("aria-controls") || "");
  if (!list)
    return;
  combobox.clearSelection();
}

// node_modules/@primer/react/lib-esm/drafts/hooks/useCombobox.js
var import_react11 = __toESM(require_react());
var useCombobox = ({
  isOpen,
  listElement: list,
  inputElement: input,
  onCommit: externalOnCommit,
  options,
  tabInsertsSuggestions = false,
  defaultFirstOption = false
}) => {
  const id = useId();
  const optionIdPrefix = `combobox-${id}__option`;
  const isOpenRef = (0, import_react11.useRef)(isOpen);
  const [comboboxInstance, setComboboxInstance] = (0, import_react11.useState)(null);
  const getOptionElements = (0, import_react11.useCallback)(() => {
    var _list$querySelectorAl;
    return [...(_list$querySelectorAl = list === null || list === void 0 ? void 0 : list.querySelectorAll("[role=option]")) !== null && _list$querySelectorAl !== void 0 ? _list$querySelectorAl : []];
  }, [list]);
  const onCommit = (0, import_react11.useCallback)((e) => {
    const nativeEvent = e;
    const indexAttr = nativeEvent.target.getAttribute("data-combobox-list-index");
    const index = indexAttr !== null ? parseInt(indexAttr, 10) : NaN;
    const option = options[index];
    if (option) externalOnCommit({
      nativeEvent,
      option
    });
  }, [options, externalOnCommit]);
  const onOptionMouseDown = (0, import_react11.useCallback)((e) => e.preventDefault(), []);
  (0, import_react11.useEffect)(function initializeComboboxInstance() {
    if (input && list) {
      if (!list.getAttribute("role")) list.setAttribute("role", "listbox");
      const cb = new Combobox(input, list, {
        tabInsertsSuggestions,
        defaultFirstOption
      });
      setComboboxInstance(cb);
      return () => {
        cb.destroy();
        setComboboxInstance(null);
      };
    }
  }, [input, list, tabInsertsSuggestions, defaultFirstOption]);
  (0, import_react11.useEffect)(function toggleKeyboardEventHandling() {
    const wasOpen = isOpenRef.current;
    isOpenRef.current = isOpen && comboboxInstance !== null;
    if (isOpen === wasOpen || !comboboxInstance) return;
    if (isOpen) {
      comboboxInstance.start();
    } else {
      comboboxInstance.stop();
    }
  }, [isOpen, comboboxInstance]);
  (0, import_react11.useEffect)(function bindCommitEvent() {
    list === null || list === void 0 ? void 0 : list.addEventListener("combobox-commit", onCommit);
    return () => list === null || list === void 0 ? void 0 : list.removeEventListener("combobox-commit", onCommit);
  }, [onCommit, list]);
  useIsomorphicLayoutEffect(() => {
    const optionElements = getOptionElements();
    for (const [i, option] of optionElements.entries()) {
      if (!option.id || option.id.startsWith(optionIdPrefix)) option.id = `${optionIdPrefix}-${i}`;
      option.setAttribute("data-combobox-list-index", i.toString());
      option.addEventListener("mousedown", onOptionMouseDown);
      option.removeAttribute("data-combobox-option-default");
    }
    comboboxInstance === null || comboboxInstance === void 0 ? void 0 : comboboxInstance.clearSelection();
    return () => {
      for (const option of optionElements) option.removeEventListener("mousedown", onOptionMouseDown);
    };
  }, [getOptionElements, optionIdPrefix, options, comboboxInstance, onOptionMouseDown]);
};

// node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/_AutocompleteSuggestions.js
var LoadingIndicator = () => import_react12.default.createElement(Box, {
  sx: {
    display: "flex",
    justifyContent: "center",
    py: 2
  }
}, import_react12.default.createElement(StyledSpinner, {
  size: "small"
}));
LoadingIndicator.displayName = "LoadingIndicator";
var SuggestionListItem = ({
  suggestion
}) => {
  const value = getSuggestionValue(suggestion);
  const sharedProps = {
    id: value,
    children: value,
    role: "option",
    sx: {
      "&[aria-selected]": {
        backgroundColor: "actionListItem.default.activeBg"
      },
      "&[data-combobox-option-default]:not([aria-selected])": {
        backgroundColor: "actionListItem.default.selectedBg"
      }
    }
  };
  return typeof suggestion === "string" ? import_react12.default.createElement(ActionList.Item, sharedProps) : suggestion.render(sharedProps);
};
var AutocompleteSuggestions = ({
  suggestions,
  portalName,
  triggerCharCoords,
  onClose,
  onCommit: externalOnCommit,
  inputRef,
  visible: visible2,
  tabInsertsSuggestions,
  defaultPlacement
}) => {
  const overlayRef = (0, import_react12.useRef)(null);
  const [list, setList] = (0, import_react12.useState)(null);
  const onCommit = (0, import_react12.useCallback)(({
    option
  }) => {
    externalOnCommit(getSuggestionValue(option));
  }, [externalOnCommit]);
  useCombobox({
    // Even though the list is visible when loading, we don't want to do keyboard binding in that case
    isOpen: visible2 && suggestions !== "loading",
    listElement: list,
    inputElement: inputRef.current,
    onCommit,
    options: Array.isArray(suggestions) ? suggestions : [],
    tabInsertsSuggestions,
    defaultFirstOption: true
  });
  const [top, setTop] = (0, import_react12.useState)(0);
  useIsomorphicLayoutEffect(
    function recalculateTop() {
      var _overlayRef$current$o, _overlayRef$current;
      const overlayHeight = (_overlayRef$current$o = (_overlayRef$current = overlayRef.current) === null || _overlayRef$current === void 0 ? void 0 : _overlayRef$current.offsetHeight) !== null && _overlayRef$current$o !== void 0 ? _overlayRef$current$o : 0;
      const belowOffset = triggerCharCoords.top + triggerCharCoords.height;
      const wouldOverflowBelow = belowOffset + overlayHeight > window.innerHeight;
      const aboveOffset = triggerCharCoords.top - overlayHeight;
      const wouldOverflowAbove = aboveOffset < 0;
      const result = {
        below: wouldOverflowBelow && !wouldOverflowAbove ? aboveOffset : belowOffset,
        above: wouldOverflowAbove && !wouldOverflowBelow ? belowOffset : aboveOffset
      }[defaultPlacement];
      const resultNotNaN = Number.isNaN(result) ? 0 : result;
      setTop(resultNotNaN);
    },
    // this is a cheap effect and we want it to run when pretty much anything that could affect position changes
    [triggerCharCoords.top, triggerCharCoords.height, suggestions, visible2, defaultPlacement]
  );
  return visible2 ? import_react12.default.createElement(Overlay, {
    onEscape: onClose,
    onClickOutside: onClose,
    returnFocusRef: inputRef,
    preventFocusOnOpen: true,
    portalContainerName: portalName,
    sx: {
      position: "fixed"
    },
    top,
    left: triggerCharCoords.left,
    ref: overlayRef
  }, import_react12.default.createElement(ActionList, {
    ref: setList,
    role: "listbox"
  }, suggestions === "loading" ? import_react12.default.createElement(LoadingIndicator, null) : suggestions === null || suggestions === void 0 ? void 0 : suggestions.map((suggestion) => import_react12.default.createElement(SuggestionListItem, {
    suggestion,
    key: getSuggestionKey(suggestion)
  })))) : import_react12.default.createElement(import_react12.default.Fragment, null);
};
AutocompleteSuggestions.displayName = "SuggestionList";

// node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/InlineAutocomplete.js
var getSelectionStart = (element) => {
  try {
    return element.selectionStart;
  } catch (e) {
    if (e instanceof TypeError) return null;
    throw e;
  }
};
var noop = () => {
};
var InlineAutocomplete = ({
  triggers,
  suggestions,
  onShowSuggestions,
  onHideSuggestions,
  onSelectSuggestion,
  sx: sx2,
  children,
  tabInsertsSuggestions = false,
  suggestionsPlacement = "below",
  ...externalInputProps
}) => {
  var _externalInput$props$, _getSelectionStart;
  const inputProps = useFormControlForwardedProps(externalInputProps);
  const inputRef = (0, import_react13.useRef)(null);
  useRefObjectAsForwardedRef(children.ref && typeof children.ref !== "string" ? children.ref : noop, inputRef);
  const externalInput = requireChildrenToBeInput(children, inputRef);
  const emitSyntheticChange = useSyntheticChange({
    inputRef,
    fallbackEventHandler: (_externalInput$props$ = externalInput.props.onChange) !== null && _externalInput$props$ !== void 0 ? _externalInput$props$ : noop
  });
  const showEventRef = (0, import_react13.useRef)(null);
  const suggestionsVisible = suggestions !== null && suggestions.length > 0;
  const triggerCharCoords = inputRef.current && showEventRef.current && suggestionsVisible ? getAbsoluteCharacterCoordinates(inputRef.current, ((_getSelectionStart = getSelectionStart(inputRef.current)) !== null && _getSelectionStart !== void 0 ? _getSelectionStart : 0) - showEventRef.current.query.length) : {
    top: 0,
    left: 0,
    height: 0
  };
  const onBlur = () => {
    onHideSuggestions();
  };
  const onKeyDown = (event) => {
    if (suggestionsVisible && event.key === "Escape") {
      onHideSuggestions();
      event.stopPropagation();
    }
  };
  const onChange = (event) => {
    const selectionStart = getSelectionStart(event.currentTarget);
    if (selectionStart === null) {
      onHideSuggestions();
      return;
    }
    showEventRef.current = calculateSuggestionsQuery(triggers, event.currentTarget.value, selectionStart);
    if (showEventRef.current) {
      onShowSuggestions(showEventRef.current);
    } else {
      onHideSuggestions();
    }
  };
  const onCommit = (suggestion) => {
    var _getSelectionStart2, _trigger$keepTriggerC;
    if (!inputRef.current || !showEventRef.current) return;
    const {
      query,
      trigger: trigger4
    } = showEventRef.current;
    onSelectSuggestion === null || onSelectSuggestion === void 0 ? void 0 : onSelectSuggestion({
      suggestion,
      trigger: trigger4,
      query
    });
    const currentCaretPosition = (_getSelectionStart2 = getSelectionStart(inputRef.current)) !== null && _getSelectionStart2 !== void 0 ? _getSelectionStart2 : 0;
    const deleteLength = query.length + trigger4.triggerChar.length;
    const startIndex = currentCaretPosition - deleteLength;
    const keepTriggerChar = (_trigger$keepTriggerC = trigger4.keepTriggerCharOnCommit) !== null && _trigger$keepTriggerC !== void 0 ? _trigger$keepTriggerC : true;
    const maybeTriggerChar = keepTriggerChar ? trigger4.triggerChar : "";
    const replacement = `${maybeTriggerChar}${suggestion} `;
    emitSyntheticChange(replacement, [startIndex, startIndex + deleteLength]);
    onHideSuggestions();
  };
  const input = (0, import_react13.cloneElement)(externalInput, {
    ...inputProps,
    onBlur: augmentHandler(externalInput.props.onBlur, onBlur),
    onKeyDown: augmentHandler(externalInput.props.onKeyDown, onKeyDown),
    onChange: augmentHandler(externalInput.props.onChange, onChange),
    ref: inputRef
  });
  const suggestionsDescription = !suggestionsVisible ? "" : suggestions === "loading" ? "Loading autocomplete suggestions" : (
    // It's important to include both Enter and Tab because we are telling the user that we are hijacking these keys:
    `${suggestions.length} autocomplete ${suggestions.length === 1 ? "suggestion" : "suggestions"} available; "${getSuggestionValue(suggestions[0])}" is highlighted. Press ${tabInsertsSuggestions ? "Enter or Tab" : "Enter"} to insert.`
  );
  return (
    // Try to get as close as possible to making the container 'invisible' by making it shrink tight to child input
    import_react13.default.createElement(Box, {
      sx: {
        display: "inline-block",
        "& > *": {
          width: "100%"
        },
        ...sx2,
        position: "relative"
      }
    }, input, import_react13.default.createElement(AutocompleteSuggestions, {
      suggestions,
      inputRef,
      onCommit,
      onClose: onHideSuggestions,
      triggerCharCoords,
      visible: suggestionsVisible,
      tabInsertsSuggestions,
      defaultPlacement: suggestionsPlacement
    }), import_react13.default.createElement(Portal, null, import_react13.default.createElement("span", {
      "aria-live": "assertive",
      "aria-atomic": true,
      style: {
        clipPath: "circle(0)",
        position: "absolute"
      }
    }, suggestionsDescription)))
  );
};
InlineAutocomplete.displayName = "InlineAutocomplete";

// node_modules/@primer/react/lib-esm/InlineMessage/InlineMessage.js
var import_react14 = __toESM(require_react());
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends3.apply(null, arguments);
}
var StyledMessage = styled_components_browser_esm_default.div.withConfig({
  displayName: "InlineMessage__StyledMessage",
  componentId: "sc-13z0tw8-0"
})(["display:grid;column-gap:0.5rem;grid-template-columns:auto 1fr;align-items:start;color:var(--inline-message-fgColor,", ");line-height:var(--inline-message-lineHeight);font-size:var(--inline-message-fontSize,", ");&[data-size='small']{--inline-message-fontSize:var(--text-body-size-small,", ");--inline-message-lineHeight:var(--text-body-lineHeight-small,1.6666);}&[data-size='medium']{--inline-message-fontSize:var(--text-body-size-medium,", ");--inline-message-lineHeight:var(--text-body-lineHeight-medium,1.4285);}&[data-variant='warning']{--inline-message-fgColor:", ";}&[data-variant='critical']{--inline-message-fgColor:", ";}&[data-variant='success']{--inline-message-fgColor:", ";}&[data-variant='unavailable']{--inline-message-fgColor:", ";}& .InlineMessageIcon{min-height:calc(var(--inline-message-lineHeight) * var(--inline-message-fontSize));}"], get("colors.neutral.emphasis"), get("fontSizes.1"), get("fontSizes.0"), get("fontSizes.1"), get("colors.attention.fg"), get("colors.danger.fg"), get("colors.success.fg"), get("colors.neutral.emphasis"));
var variantToIcon = {
  warning: import_react14.default.createElement(AlertIcon, {
    className: "InlineMessageIcon"
  }),
  critical: import_react14.default.createElement(AlertIcon, {
    className: "InlineMessageIcon"
  }),
  success: import_react14.default.createElement(CheckCircleIcon, {
    className: "InlineMessageIcon"
  }),
  unavailable: import_react14.default.createElement(AlertIcon, {
    className: "InlineMessageIcon"
  })
};
var variantToSmallIcon = {
  warning: import_react14.default.createElement(AlertFillIcon, {
    className: "InlineMessageIcon",
    size: 12
  }),
  critical: import_react14.default.createElement(AlertFillIcon, {
    className: "InlineMessageIcon",
    size: 12
  }),
  success: import_react14.default.createElement(CheckCircleFillIcon, {
    className: "InlineMessageIcon",
    size: 12
  }),
  unavailable: import_react14.default.createElement(AlertFillIcon, {
    className: "InlineMessageIcon",
    size: 12
  })
};
function InlineMessage({
  children,
  size = "medium",
  variant,
  ...rest
}) {
  const icon = size === "small" ? variantToSmallIcon[variant] : variantToIcon[variant];
  return import_react14.default.createElement(StyledMessage, _extends3({}, rest, {
    "data-size": size,
    "data-variant": variant
  }), icon, children);
}
InlineMessage.displayName = "InlineMessage";

// node_modules/@primer/react/lib-esm/drafts/MarkdownViewer/MarkdownViewer.js
var import_react18 = __toESM(require_react());
var import_deepmerge = __toESM(require_cjs());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@primer/react/lib-esm/drafts/MarkdownViewer/_useLinkInterception.js
var import_react15 = __toESM(require_react());
var useLinkInterception = ({
  htmlContainer,
  onLinkClick,
  openLinksInNewTab
}) => {
  (0, import_react15.useEffect)(() => {
    const clickHandler = (event) => {
      const link = event.target.closest("a");
      if (!link) return;
      onLinkClick === null || onLinkClick === void 0 ? void 0 : onLinkClick(event);
      if (!event.defaultPrevented && openLinksInNewTab && link.href) {
        window.open(link.href, "_blank", "noopener noreferrer");
        event.preventDefault();
      }
    };
    if (!htmlContainer) return;
    htmlContainer.addEventListener("click", clickHandler);
    return () => {
      htmlContainer.removeEventListener("click", clickHandler);
    };
  }, [htmlContainer, onLinkClick, openLinksInNewTab]);
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownViewer/_useListInteraction.js
var import_react17 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_useListEditing.js
var import_react16 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/utils.js
var getSelectedLineRange = (textarea) => {
  const start = textarea.value.lastIndexOf("\n", textarea.selectionStart - 1) + 1;
  let end = textarea.value.indexOf("\n", textarea.selectionEnd);
  if (end === -1) end = textarea.value.length;
  return [start, end];
};
var markdownComment = (text) => `<!-- ${text.replaceAll("--", "\\-\\-")} -->`;
var markdownLink = (text, url) => `[${text.replaceAll("[", "\\[").replaceAll("]", "\\]")}](${url.replaceAll("(", "\\(").replaceAll(")", "\\)")})`;
var markdownImage = (altText, url) => `!${markdownLink(altText, url)}`;
var isModifierKey = (event) => isMacOS() ? event.metaKey : event.ctrlKey;

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_useListEditing.js
var calculateNextListItemStarter = ({
  leadingWhitespace = "",
  delimeter,
  taskBox,
  text
}) => {
  if (!text) return null;
  const updatedDelimeter = typeof delimeter === "number" ? `${delimeter + 1}.` : delimeter;
  const maybeEmptyTaskBox = taskBox ? " [ ]" : "";
  return `
${leadingWhitespace}${updatedDelimeter}${maybeEmptyTaskBox} `;
};
var listItemRegex = /^(\s*)([*-]|(\d+)\.)(\s{1,4})(?:(\[[\sx]\])\s)?(.*)/i;
var isNumericListItem = (item) => typeof (item === null || item === void 0 ? void 0 : item.delimeter) === "number";
var parseListItem = (line) => {
  const result = listItemRegex.exec(line);
  if (!result) return null;
  const [, leadingWhitespace = "", fullDelimeter, itemNumberStr = "", middleWhitespace, taskBox = null, text] = result;
  const itemNumber = Number.parseInt(itemNumberStr, 10);
  const delimeter = Number.isNaN(itemNumber) ? fullDelimeter : itemNumber;
  return {
    leadingWhitespace,
    text,
    delimeter,
    middleWhitespace,
    taskBox
  };
};
var listItemToString = (item) => typeof item.delimeter === "number" ? `${item.leadingWhitespace}${`${item.delimeter}.`}${item.middleWhitespace}${item.text}` : `${item.leadingWhitespace}${item.delimeter}${item.middleWhitespace}${item.taskBox || ""} ${item.text}`;
var useListEditing = ({
  emitChange
}) => {
  const incrementFollowingNumericLines = (0, import_react16.useCallback)((textarea) => {
    const [currentLineStart, currentLineEnd] = getSelectedLineRange(textarea);
    const currentLineText = textarea.value.slice(currentLineStart, currentLineEnd);
    const currentLineItem = parseListItem(currentLineText);
    if (!isNumericListItem(currentLineItem)) return;
    const followingText = textarea.value.slice(currentLineEnd + 1);
    const followingLines = followingText.split(/\r?\n/);
    const followingNumericListItems = [];
    let prevItemNumber = currentLineItem.delimeter;
    for (const line of followingLines) {
      const listItem = parseListItem(line);
      if (!isNumericListItem(listItem) || listItem.delimeter !== prevItemNumber) break;
      followingNumericListItems.push(listItem);
      prevItemNumber++;
    }
    if (followingNumericListItems.length === 0) return;
    const updatedItems = `
${followingNumericListItems.map((item) => listItemToString({
      ...item,
      delimeter: item.delimeter + 1
    })).join("\n")}`;
    emitChange(updatedItems, [currentLineEnd, currentLineEnd + updatedItems.length + 1], textarea.selectionStart);
  }, [emitChange]);
  const onKeyDown = (0, import_react16.useCallback)((event) => {
    if (event.key === "Enter" && !event.shiftKey && !event.defaultPrevented) {
      const textarea = event.currentTarget;
      const [activeLineStart, activeLineEnd] = getSelectedLineRange(textarea);
      const activeLineValue = textarea.value.slice(activeLineStart, textarea.selectionStart) + textarea.value.slice(textarea.selectionEnd, activeLineEnd);
      const listItem = parseListItem(activeLineValue);
      if (!listItem) return;
      event.preventDefault();
      const nextItemStarter = calculateNextListItemStarter(listItem);
      if (nextItemStarter === null) {
        emitChange("", [activeLineStart, textarea.selectionEnd]);
      } else {
        emitChange(nextItemStarter);
        incrementFollowingNumericLines(textarea);
      }
    }
  }, [emitChange, incrementFollowingNumericLines]);
  return {
    onKeyDown
  };
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownViewer/_useListInteraction.js
var parseCodeFenceBegin = (line) => {
  const match = line.match(/^ {0,3}(`{3,}|~{3,})[^`]*$/);
  return match ? match[1] : null;
};
var isCodeFenceEnd = (line, fence) => {
  const regex = new RegExp(`^ {0,3}${fence}${fence[0]}* *$`);
  return regex.test(line);
};
var isTaskListItem = (item) => typeof (item === null || item === void 0 ? void 0 : item.taskBox) === "string";
var toggleTaskListItem = (item) => ({
  ...item,
  taskBox: item.taskBox === "[ ]" ? "[x]" : "[ ]"
});
var useListInteraction = ({
  htmlContainer,
  markdownValue,
  onChange,
  disabled = false,
  dependencies = []
}) => {
  const markdownRef = (0, import_react17.useRef)(markdownValue);
  useIsomorphicLayoutEffect(() => {
    markdownRef.current = markdownValue;
  }, [markdownValue]);
  const onToggleItem = (0, import_react17.useCallback)((toggledItemIndex) => () => {
    const lines = markdownRef.current.split(/\r?\n/);
    let currentCodeFence = null;
    for (let lineIndex = 0, taskIndex = 0; lineIndex < lines.length; lineIndex++) {
      const line = lines[lineIndex];
      if (!currentCodeFence) {
        currentCodeFence = parseCodeFenceBegin(line);
      } else if (isCodeFenceEnd(line, currentCodeFence)) {
        currentCodeFence = null;
        continue;
      }
      if (currentCodeFence) continue;
      const parsedLine = parseListItem(line);
      if (!isTaskListItem(parsedLine)) continue;
      if (taskIndex === toggledItemIndex) {
        const updatedLine = listItemToString(toggleTaskListItem(parsedLine));
        lines.splice(lineIndex, 1, updatedLine);
        const updatedMarkdown = lines.join("\n");
        markdownRef.current = updatedMarkdown;
        onChange(updatedMarkdown);
        return;
      }
      taskIndex++;
    }
  }, [onChange]);
  const [checkboxElements, setCheckboxElements] = (0, import_react17.useState)([]);
  (0, import_react17.useEffect)(
    () => {
      var _htmlContainer$queryS;
      setCheckboxElements(Array.from((_htmlContainer$queryS = htmlContainer === null || htmlContainer === void 0 ? void 0 : htmlContainer.querySelectorAll("input[type=checkbox].task-list-item-checkbox")) !== null && _htmlContainer$queryS !== void 0 ? _htmlContainer$queryS : []));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [htmlContainer, ...dependencies]
  );
  (0, import_react17.useEffect)(function enableOrDisableCheckboxes() {
    const cleanupFns = checkboxElements.map((el) => {
      const previouslyDisabled = el.disabled;
      el.disabled = disabled;
      return () => {
        el.disabled = previouslyDisabled;
      };
    });
    return () => cleanupFns.forEach((fn) => fn());
  }, [checkboxElements, disabled]);
  (0, import_react17.useEffect)(function bindEventListeners() {
    const cleanupFns = checkboxElements.map((el, i) => {
      const toggleHandler = onToggleItem(i);
      el.addEventListener("change", toggleHandler);
      return () => el.removeEventListener("change", toggleHandler);
    });
    return () => cleanupFns.forEach((fn) => fn());
  }, [checkboxElements, onToggleItem]);
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownViewer/MarkdownViewer.js
var MarkdownViewer = ({
  dangerousRenderedHTML,
  loading = false,
  markdownValue = "",
  onChange: externalOnChange,
  disabled = false,
  onLinkClick,
  openLinksInNewTab = false
}) => {
  const [htmlContainer, setHtmlContainer] = import_react18.default.useState();
  const htmlContainerRef = import_react18.default.useCallback((node) => {
    if (!node) return;
    setHtmlContainer(node);
  }, []);
  const onChange = (0, import_react18.useCallback)(async (value) => {
    try {
      await (externalOnChange === null || externalOnChange === void 0 ? void 0 : externalOnChange(value));
    } catch (error) {
      if (htmlContainer) {
        htmlContainer.innerHTML = dangerousRenderedHTML.__html;
      }
    }
  }, [externalOnChange, htmlContainer, dangerousRenderedHTML]);
  useListInteraction({
    onChange,
    disabled: disabled || !externalOnChange,
    htmlContainer,
    markdownValue,
    dependencies: [dangerousRenderedHTML]
  });
  useLinkInterception({
    htmlContainer,
    onLinkClick,
    openLinksInNewTab
  });
  return loading ? import_react18.default.createElement(Box, {
    sx: {
      display: "flex",
      justifyContent: "space-around",
      p: 2
    }
  }, import_react18.default.createElement(StyledSpinner, {
    "aria-label": "Loading content..."
  })) : import_react18.default.createElement(Box, {
    ref: htmlContainerRef,
    className: "markdown-body",
    sx: {
      fontSize: 1,
      maxWidth: "100%",
      "& > div > :last-child": {
        mb: 0
      }
    },
    dangerouslySetInnerHTML: dangerousRenderedHTML
  });
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/MarkdownEditor.js
var import_react41 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/hooks/useIgnoreKeyboardActionsWhileComposing.js
var import_react20 = __toESM(require_react());
var useIgnoreKeyboardActionsWhileComposing = (onKeyDown) => {
  const isComposingRef = (0, import_react20.useRef)(false);
  const hasCompositionEndedRef = (0, import_react20.useRef)(false);
  const handleComposition = (0, import_react20.useCallback)((event) => {
    if (event.type === "compositionstart") {
      isComposingRef.current = true;
      hasCompositionEndedRef.current = false;
    }
    if (event.type === "compositionend") {
      isComposingRef.current = false;
      hasCompositionEndedRef.current = true;
    }
  }, []);
  const wrappedOnKeyDown = (0, import_react20.useCallback)((event) => {
    if (event.key === "Enter" && isComposingRef.current) {
      return;
    }
    if (isMacOS() && event.keyCode === 229 && hasCompositionEndedRef.current) {
      hasCompositionEndedRef.current = false;
      return;
    }
    onKeyDown(event);
  }, [onKeyDown]);
  const inputProps = (0, import_react20.useMemo)(() => {
    return {
      onCompositionStart: handleComposition,
      onCompositionEnd: handleComposition,
      onKeyDown: wrappedOnKeyDown
    };
  }, [handleComposition, wrappedOnKeyDown]);
  return inputProps;
};

// node_modules/@primer/react/lib-esm/drafts/hooks/useSafeAsyncCallback.js
var import_react21 = __toESM(require_react());
var callbackCancelledResult = Symbol("callbackCancelledResult");
var useSafeAsyncCallback = (fn, allowCallingAfterUnmount = false) => {
  const trackingRef = (0, import_react21.useRef)(fn);
  useIsomorphicLayoutEffect(() => {
    trackingRef.current = fn;
  }, [fn]);
  const isMountedRef = (0, import_react21.useRef)(false);
  (0, import_react21.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      if (!allowCallingAfterUnmount) isMountedRef.current = false;
    };
  }, [allowCallingAfterUnmount]);
  return (0, import_react21.useCallback)(
    (...args) => isMountedRef.current ? trackingRef.current(...args) : callbackCancelledResult,
    []
    // this dependency array must always be empty
  );
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/Actions.js
var import_react23 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_MarkdownEditorContext.js
var import_react22 = __toESM(require_react());
var MarkdownEditorContext = (0, import_react22.createContext)({
  disabled: false,
  condensed: false,
  required: false,
  formattingToolsRef: {
    current: null
  },
  uploadButtonProps: null,
  fileDraggedOver: false,
  previewMode: false
});

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/Actions.js
function _extends4() {
  return _extends4 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends4.apply(null, arguments);
}
var Actions = ({
  children
}) => import_react23.default.createElement(import_react23.default.Fragment, null, children);
Actions.displayName = "MarkdownEditor.Actions";
var ActionButton = (0, import_react23.forwardRef)((props, ref) => {
  const {
    disabled
  } = (0, import_react23.useContext)(MarkdownEditorContext);
  return import_react23.default.createElement(ButtonComponent, _extends4({
    ref,
    disabled
  }, props));
});
ActionButton.displayName = "MarkdownEditor.ActionButton";

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/Label.js
var import_react24 = __toESM(require_react());
function _extends5() {
  return _extends5 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends5.apply(null, arguments);
}
var Legend = ({
  sx: sx2,
  ...props
}) => {
  const {
    disabled,
    required
  } = (0, import_react24.useContext)(MarkdownEditorContext);
  return import_react24.default.createElement(InputLabel, _extends5({
    as: "legend",
    disabled,
    required
  }, props, {
    sx: {
      cursor: "default",
      mb: 1,
      ...sx2
    }
  }));
};
Legend.displayName = "Legend";
Legend.displayName = "MarkdownEditor.Label";
var Label = (props) => import_react24.default.createElement(Legend, props);
Label.displayName = "Label";

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/Toolbar.js
var import_react27 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_SavedReplies.js
var import_react26 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_ToolbarButton.js
var import_react25 = __toESM(require_react());
function _extends6() {
  return _extends6 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends6.apply(null, arguments);
}
var ToolbarButton = (0, import_react25.forwardRef)((props, ref) => {
  const {
    disabled,
    condensed
  } = (0, import_react25.useContext)(MarkdownEditorContext);
  return import_react25.default.createElement(IconButton, _extends6({
    ref,
    size: condensed ? "small" : "medium",
    variant: "invisible",
    disabled,
    onMouseDown: (e) => e.preventDefault()
  }, props, {
    sx: {
      color: "fg.muted",
      ...props.sx
    },
    unsafeDisableTooltip: true
  }));
});
ToolbarButton.displayName = "MarkdownEditor.ToolbarButton";

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_SavedReplies.js
function _extends7() {
  return _extends7 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends7.apply(null, arguments);
}
var SavedRepliesContext = (0, import_react26.createContext)(null);
var SavedRepliesButton = () => {
  const context = (0, import_react26.useContext)(SavedRepliesContext);
  (0, import_react26.useImperativeHandle)(context === null || context === void 0 ? void 0 : context.ref, () => ({
    openMenu: () => {
      setOpen(true);
    }
  }));
  const [open, setOpen] = (0, import_react26.useState)(false);
  (0, import_react26.useEffect)(() => setFilter(""), [open]);
  const [filter, setFilter] = (0, import_react26.useState)("");
  const items = context === null || context === void 0 ? void 0 : context.savedReplies.filter(({
    name
  }) => name.toLowerCase().includes(filter.toLowerCase())).map((reply, i) => ({
    text: reply.name,
    description: reply.content,
    descriptionVariant: "block",
    trailingVisual: i < 9 ? `Ctrl + ${i + 1}` : void 0,
    sx: {
      // hide the leading visual container since we don't use the checkboxes
      "& [class*=BaseVisualContainer]:first-child": {
        display: "none"
      },
      "& [class*=DescriptionContainer]": {
        whiteSpace: "nowrap",
        overflow: "hidden",
        textOverflow: "ellipsis",
        maxWidth: "100%"
      }
    }
  }));
  const onSelectItem = (item) => {
    setOpen(false);
    const reply = context === null || context === void 0 ? void 0 : context.savedReplies.find(({
      name
    }) => name === (item === null || item === void 0 ? void 0 : item.text));
    if (reply) context === null || context === void 0 ? void 0 : context.onSelect(reply);
  };
  const onKeyDown = (event) => {
    const keyInt = parseInt(event.key, 10);
    if (items && event.ctrlKey && !Number.isNaN(keyInt) && keyInt >= 1 && keyInt <= 9) {
      event.stopPropagation();
      event.preventDefault();
      onSelectItem(items[keyInt - 1]);
    }
  };
  return items ? import_react26.default.createElement(SelectPanel, {
    renderAnchor: (props) => import_react26.default.createElement(ToolbarButton, _extends7({}, props, {
      icon: ReplyIcon,
      "aria-label": "Add saved reply (Ctrl + .)",
      "aria-labelledby": void 0
    })),
    open,
    onOpenChange: setOpen,
    items,
    filterValue: filter,
    onFilterChange: setFilter,
    placeholderText: "Search saved replies",
    selected: void 0,
    onSelectedChange: (selection) => {
      onSelectItem(Array.isArray(selection) ? selection[0] : selection);
    },
    overlayProps: {
      width: "small",
      maxHeight: "small",
      anchorSide: "outside-right",
      onKeyDown
    }
  }) : import_react26.default.createElement(import_react26.default.Fragment, null);
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/Toolbar.js
var Divider = () => {
  return import_react27.default.createElement(Box, {
    sx: {
      display: "inline-grid",
      margin: "0 var(--controlStack-medium-gap-condensed, 8px)",
      height: "calc(var(--control-medium-size, 32px)/2)",
      borderLeft: "var(--borderWidth-thin, 1px) solid var(--borderColor-muted)"
    }
  });
};
Divider.displayName = "Divider";
var DefaultToolbarButtons = (0, import_react27.memo)(() => {
  const {
    condensed,
    formattingToolsRef
  } = (0, import_react27.useContext)(MarkdownEditorContext);
  const cmdOrCtrl = isMacOS() ? "Cmd" : "Ctrl";
  return import_react27.default.createElement(import_react27.default.Fragment, null, import_react27.default.createElement(Box, null, import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c;
      return (_formattingToolsRef$c = formattingToolsRef.current) === null || _formattingToolsRef$c === void 0 ? void 0 : _formattingToolsRef$c.header();
    },
    icon: HeadingIcon,
    "aria-label": "Add header text"
  }), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c2;
      return (_formattingToolsRef$c2 = formattingToolsRef.current) === null || _formattingToolsRef$c2 === void 0 ? void 0 : _formattingToolsRef$c2.bold();
    },
    icon: BoldIcon,
    "aria-label": `Bold (${cmdOrCtrl} + B)`
  }), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c3;
      return (_formattingToolsRef$c3 = formattingToolsRef.current) === null || _formattingToolsRef$c3 === void 0 ? void 0 : _formattingToolsRef$c3.italic();
    },
    icon: ItalicIcon,
    "aria-label": `Italic (${cmdOrCtrl} + I)`
  })), import_react27.default.createElement(Box, null, import_react27.default.createElement(Divider, null), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c4;
      return (_formattingToolsRef$c4 = formattingToolsRef.current) === null || _formattingToolsRef$c4 === void 0 ? void 0 : _formattingToolsRef$c4.quote();
    },
    icon: QuoteIcon,
    "aria-label": `Insert a quote (${cmdOrCtrl} + Shift + .)`
  }), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c5;
      return (_formattingToolsRef$c5 = formattingToolsRef.current) === null || _formattingToolsRef$c5 === void 0 ? void 0 : _formattingToolsRef$c5.code();
    },
    icon: CodeIcon,
    "aria-label": `Insert code (${cmdOrCtrl} + E)`
  }), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c6;
      return (_formattingToolsRef$c6 = formattingToolsRef.current) === null || _formattingToolsRef$c6 === void 0 ? void 0 : _formattingToolsRef$c6.link();
    },
    icon: LinkIcon,
    "aria-label": `Add a link (${cmdOrCtrl} + K)`
  })), import_react27.default.createElement(Box, null, import_react27.default.createElement(Divider, null), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c7;
      return (_formattingToolsRef$c7 = formattingToolsRef.current) === null || _formattingToolsRef$c7 === void 0 ? void 0 : _formattingToolsRef$c7.unorderedList();
    },
    icon: ListUnorderedIcon,
    "aria-label": `Add a bulleted list (${cmdOrCtrl} + 8)`
  }), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c8;
      return (_formattingToolsRef$c8 = formattingToolsRef.current) === null || _formattingToolsRef$c8 === void 0 ? void 0 : _formattingToolsRef$c8.orderedList();
    },
    icon: ListOrderedIcon,
    "aria-label": `Add a numbered list (${cmdOrCtrl} + Shift + 7)`
  }), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c9;
      return (_formattingToolsRef$c9 = formattingToolsRef.current) === null || _formattingToolsRef$c9 === void 0 ? void 0 : _formattingToolsRef$c9.taskList();
    },
    icon: TasklistIcon,
    "aria-label": `Add a task list (${cmdOrCtrl} + Shift + L)`
  })), !condensed && import_react27.default.createElement(Box, null, import_react27.default.createElement(Divider, null), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c10;
      return (_formattingToolsRef$c10 = formattingToolsRef.current) === null || _formattingToolsRef$c10 === void 0 ? void 0 : _formattingToolsRef$c10.mention();
    },
    icon: MentionIcon,
    "aria-label": "Mention a user or team (@)"
  }), import_react27.default.createElement(ToolbarButton, {
    onClick: () => {
      var _formattingToolsRef$c11;
      return (_formattingToolsRef$c11 = formattingToolsRef.current) === null || _formattingToolsRef$c11 === void 0 ? void 0 : _formattingToolsRef$c11.reference();
    },
    icon: CrossReferenceIcon,
    "aria-label": "Reference an issue, pull request, or discussion (#)"
  })), import_react27.default.createElement(SavedRepliesButton, null));
});
DefaultToolbarButtons.displayName = "MarkdownEditor.DefaultToolbarButtons";
var CoreToolbar = ({
  children
}) => {
  const containerRef = (0, import_react27.useRef)(null);
  useFocusZone({
    containerRef,
    focusInStrategy: "closest",
    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,
    focusOutBehavior: "wrap"
  });
  return import_react27.default.createElement(Box, {
    ref: containerRef,
    "aria-label": "Formatting tools",
    role: "toolbar",
    sx: {
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "flex-end",
      gap: 0,
      alignItems: "center",
      flexGrow: 1,
      borderBottom: "1px solid",
      borderBottomColor: "border.muted",
      pl: 2,
      pr: 1
    }
  }, children);
};
CoreToolbar.displayName = "CoreToolbar";
var Toolbar = ({
  children
}) => import_react27.default.createElement(CoreToolbar, null, children);
Toolbar.displayName = "Toolbar";
Toolbar.displayName = "MarkdownEditor.Toolbar";

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/Footer.js
var import_react28 = __toESM(require_react());
var import_deepmerge2 = __toESM(require_cjs());
var import_react_dom2 = __toESM(require_react_dom());
function _extends8() {
  return _extends8 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends8.apply(null, arguments);
}
var uploadingNote = ([current, total]) => total === 1 ? `Uploading your file` : `Uploading your files (${current}/${total})`;
var CoreFooter = ({
  children
}) => {
  const [slots, childrenWithoutSlots] = useSlots(children, {
    footerButtons: FooterButton
  });
  const {
    fileUploadProgress,
    previewMode
  } = (0, import_react28.useContext)(MarkdownEditorContext);
  return import_react28.default.createElement(Box, {
    sx: {
      pt: 2,
      display: "flex",
      gap: 2,
      justifyContent: "space-between",
      alignItems: "center",
      minHeight: "36px"
    },
    as: "footer"
  }, import_react28.default.createElement(Box, {
    sx: {
      display: "flex",
      gap: 1,
      alignItems: "center",
      fontSize: 0
    }
  }, previewMode ? import_react28.default.createElement(import_react28.default.Fragment, null) : fileUploadProgress ? import_react28.default.createElement(Text, {
    sx: {
      py: 1,
      px: 2,
      color: "fg.muted"
    }
  }, import_react28.default.createElement(StyledSpinner, {
    size: "small",
    sx: {
      mr: 1,
      verticalAlign: "text-bottom"
    }
  }), " ", uploadingNote(fileUploadProgress)) : null, slots.footerButtons && import_react28.default.createElement(Box, {
    sx: {
      display: "flex",
      gap: 2
    }
  }, slots.footerButtons), import_react28.default.createElement(DefaultFooterButtons, null)), !fileUploadProgress && import_react28.default.createElement(Box, {
    sx: {
      display: "flex",
      gap: 2
    }
  }, childrenWithoutSlots));
};
CoreFooter.displayName = "CoreFooter";
var Footer = ({
  children
}) => import_react28.default.createElement(CoreFooter, null, children);
Footer.displayName = "Footer";
Footer.displayName = "MarkdownEditor.Footer";
var FooterButton = (0, import_react28.forwardRef)((props, ref) => {
  const {
    disabled
  } = (0, import_react28.useContext)(MarkdownEditorContext);
  return import_react28.default.createElement(ButtonComponent, _extends8({
    ref,
    size: "small",
    disabled
  }, props));
});
FooterButton.displayName = "MarkdownEditor.FooterButton";
var DefaultFooterButtons = (0, import_react28.memo)(() => {
  const {
    uploadButtonProps,
    fileDraggedOver
  } = (0, import_react28.useContext)(MarkdownEditorContext);
  return uploadButtonProps ? import_react28.default.createElement(FileUploadButton, _extends8({
    fileDraggedOver
  }, uploadButtonProps)) : null;
});
DefaultFooterButtons.displayName = "MarkdownEditor.DefaultFooterButtons";
var FileUploadButton = (0, import_react28.memo)(({
  fileDraggedOver,
  ...props
}) => {
  const {
    condensed,
    disabled
  } = (0, import_react28.useContext)(MarkdownEditorContext);
  return import_react28.default.createElement(ButtonComponent, _extends8({
    variant: "invisible",
    leadingVisual: PaperclipIcon,
    size: "small",
    sx: {
      color: "fg.muted",
      fontWeight: "normal",
      px: 2
    },
    onMouseDown: (e) => {
      e.preventDefault();
    },
    disabled
  }, props), condensed ? "Add files" : fileDraggedOver ? "Drop to add files" : "Paste, drop, or click to add files");
});

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_FormattingTools.js
var import_react30 = __toESM(require_react());
var hasRegisteredToolbarElement = false;
var FormattingTools = (0, import_react30.forwardRef)(({
  forInputId
}, forwadedRef) => {
  (0, import_react30.useEffect)(() => {
    if (!hasRegisteredToolbarElement) init_dist();
    hasRegisteredToolbarElement = true;
  }, []);
  const headerRef = (0, import_react30.useRef)(null);
  const boldRef = (0, import_react30.useRef)(null);
  const italicRef = (0, import_react30.useRef)(null);
  const quoteRef = (0, import_react30.useRef)(null);
  const codeRef = (0, import_react30.useRef)(null);
  const linkRef = (0, import_react30.useRef)(null);
  const unorderedListRef = (0, import_react30.useRef)(null);
  const orderedListRef = (0, import_react30.useRef)(null);
  const taskListRef = (0, import_react30.useRef)(null);
  const mentionRef = (0, import_react30.useRef)(null);
  const referenceRef = (0, import_react30.useRef)(null);
  (0, import_react30.useImperativeHandle)(forwadedRef, () => ({
    header: () => {
      var _headerRef$current;
      return (_headerRef$current = headerRef.current) === null || _headerRef$current === void 0 ? void 0 : _headerRef$current.click();
    },
    bold: () => {
      var _boldRef$current;
      return (_boldRef$current = boldRef.current) === null || _boldRef$current === void 0 ? void 0 : _boldRef$current.click();
    },
    italic: () => {
      var _italicRef$current;
      return (_italicRef$current = italicRef.current) === null || _italicRef$current === void 0 ? void 0 : _italicRef$current.click();
    },
    quote: () => {
      var _quoteRef$current;
      return (_quoteRef$current = quoteRef.current) === null || _quoteRef$current === void 0 ? void 0 : _quoteRef$current.click();
    },
    code: () => {
      var _codeRef$current;
      return (_codeRef$current = codeRef.current) === null || _codeRef$current === void 0 ? void 0 : _codeRef$current.click();
    },
    link: () => {
      var _linkRef$current;
      return (_linkRef$current = linkRef.current) === null || _linkRef$current === void 0 ? void 0 : _linkRef$current.click();
    },
    unorderedList: () => {
      var _unorderedListRef$cur;
      return (_unorderedListRef$cur = unorderedListRef.current) === null || _unorderedListRef$cur === void 0 ? void 0 : _unorderedListRef$cur.click();
    },
    orderedList: () => {
      var _orderedListRef$curre;
      return (_orderedListRef$curre = orderedListRef.current) === null || _orderedListRef$curre === void 0 ? void 0 : _orderedListRef$curre.click();
    },
    taskList: () => {
      var _taskListRef$current;
      return (_taskListRef$current = taskListRef.current) === null || _taskListRef$current === void 0 ? void 0 : _taskListRef$current.click();
    },
    mention: () => {
      var _mentionRef$current;
      return (_mentionRef$current = mentionRef.current) === null || _mentionRef$current === void 0 ? void 0 : _mentionRef$current.click();
    },
    reference: () => {
      var _referenceRef$current;
      return (_referenceRef$current = referenceRef.current) === null || _referenceRef$current === void 0 ? void 0 : _referenceRef$current.click();
    }
  }));
  return import_react30.default.createElement("markdown-toolbar", {
    for: forInputId,
    style: {
      display: "none"
    }
  }, import_react30.default.createElement("md-header", {
    ref: headerRef
  }), import_react30.default.createElement("md-bold", {
    ref: boldRef
  }), import_react30.default.createElement("md-italic", {
    ref: italicRef
  }), import_react30.default.createElement("md-quote", {
    ref: quoteRef
  }), import_react30.default.createElement("md-code", {
    ref: codeRef
  }), import_react30.default.createElement("md-link", {
    ref: linkRef
  }), import_react30.default.createElement("md-unordered-list", {
    ref: unorderedListRef
  }), import_react30.default.createElement("md-ordered-list", {
    ref: orderedListRef
  }), import_react30.default.createElement("md-task-list", {
    ref: taskListRef
  }), import_react30.default.createElement("md-mention", {
    ref: mentionRef
  }), import_react30.default.createElement("md-ref", {
    ref: referenceRef
  }));
});

// node_modules/@github/paste-markdown/dist/text.js
function insertText2(textarea, text) {
  var _a2, _b, _c;
  const before = textarea.value.slice(0, (_a2 = textarea.selectionStart) !== null && _a2 !== void 0 ? _a2 : void 0);
  const after = textarea.value.slice((_b = textarea.selectionEnd) !== null && _b !== void 0 ? _b : void 0);
  let canInsertText2 = true;
  textarea.contentEditable = "true";
  try {
    canInsertText2 = document.execCommand("insertText", false, text);
  } catch (error) {
    canInsertText2 = false;
  }
  textarea.contentEditable = "false";
  if (canInsertText2 && !textarea.value.slice(0, (_c = textarea.selectionStart) !== null && _c !== void 0 ? _c : void 0).endsWith(text)) {
    canInsertText2 = false;
  }
  if (!canInsertText2) {
    try {
      document.execCommand("ms-beginUndoUnit");
    } catch (e) {
    }
    textarea.value = before + text + after;
    try {
      document.execCommand("ms-endUndoUnit");
    } catch (e) {
    }
    textarea.dispatchEvent(new CustomEvent("change", { bubbles: true, cancelable: true }));
  }
}

// node_modules/@github/paste-markdown/dist/paste-keyboard-shortcut-helper.js
var skipFormattingMap = /* @__PURE__ */ new WeakMap();
function setSkipFormattingFlag(event) {
  const { currentTarget: el } = event;
  const isSkipFormattingKeys = event.code === "KeyV" && (event.ctrlKey || event.metaKey) && event.shiftKey;
  if (isSkipFormattingKeys || isSkipFormattingKeys && event.altKey) {
    skipFormattingMap.set(el, true);
  }
}
function unsetSkipFormattedFlag(event) {
  const { currentTarget: el } = event;
  skipFormattingMap.delete(el);
}
function shouldSkipFormatting(el) {
  var _a2;
  const shouldSkipFormattingState = (_a2 = skipFormattingMap.get(el)) !== null && _a2 !== void 0 ? _a2 : false;
  return shouldSkipFormattingState;
}
function installAround(el, installCallbacks, optionConfig) {
  el.addEventListener("keydown", setSkipFormattingFlag);
  for (const installCallback of installCallbacks) {
    installCallback(el, optionConfig);
  }
  el.addEventListener("paste", unsetSkipFormattedFlag);
}
function uninstall(el) {
  el.removeEventListener("keydown", setSkipFormattingFlag);
  el.removeEventListener("paste", unsetSkipFormattedFlag);
}

// node_modules/@github/paste-markdown/dist/paste-markdown-html.js
function install(el) {
  el.addEventListener("paste", onPaste);
}
function uninstall2(el) {
  el.removeEventListener("paste", onPaste);
}
function onPaste(event) {
  const transfer = event.clipboardData;
  const { currentTarget: el } = event;
  if (shouldSkipFormatting(el))
    return;
  if (!transfer || !hasHTML(transfer))
    return;
  const field = event.currentTarget;
  if (!(field instanceof HTMLTextAreaElement))
    return;
  if (isWithinUserMention(field)) {
    return;
  }
  let plaintext = transfer.getData("text/plain");
  const textHTML = transfer.getData("text/html");
  const textHTMLClean = textHTML.replace(/\u00A0/g, " ").replace(/\uC2A0/g, " ");
  if (!textHTML)
    return;
  plaintext = plaintext.trim();
  if (!plaintext)
    return;
  const parser = new DOMParser();
  const doc = parser.parseFromString(textHTMLClean, "text/html");
  const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ALL, (node) => node.parentNode && isLink(node.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT);
  const markdown2 = convertToMarkdown(plaintext, walker);
  if (markdown2 === plaintext)
    return;
  event.stopPropagation();
  event.preventDefault();
  insertText2(field, markdown2);
}
function convertToMarkdown(plaintext, walker) {
  let currentNode = walker.firstChild();
  let markdown2 = plaintext;
  let markdownIgnoreBeforeIndex = 0;
  let index = 0;
  const NODE_LIMIT = 1e4;
  while (currentNode && index < NODE_LIMIT) {
    index++;
    const text = isLink(currentNode) ? (currentNode.textContent || "").replace(/[\t\n\r ]+/g, " ") : (currentNode === null || currentNode === void 0 ? void 0 : currentNode.wholeText) || "";
    if (isEmptyString(text)) {
      currentNode = walker.nextNode();
      continue;
    }
    if (!isLink(currentNode)) {
      markdownIgnoreBeforeIndex += text.replace(/[\t\n\r ]+/g, " ").trimStart().length;
      currentNode = walker.nextNode();
      continue;
    }
    const markdownFoundIndex = markdown2.indexOf(text, markdownIgnoreBeforeIndex);
    if (markdownFoundIndex >= 0) {
      const markdownLink2 = linkify(currentNode, text);
      markdown2 = markdown2.slice(0, markdownFoundIndex) + markdownLink2 + markdown2.slice(markdownFoundIndex + text.length);
      markdownIgnoreBeforeIndex = markdownFoundIndex + markdownLink2.length;
    }
    currentNode = walker.nextNode();
  }
  return index === NODE_LIMIT ? plaintext : markdown2;
}
function isWithinUserMention(textarea) {
  const selectionStart = textarea.selectionStart || 0;
  if (selectionStart === 0) {
    return false;
  }
  const previousChar = textarea.value.substring(selectionStart - 1, selectionStart);
  return previousChar === "@";
}
function isEmptyString(text) {
  return !text || (text === null || text === void 0 ? void 0 : text.trim().length) === 0;
}
function isLink(node) {
  var _a2;
  return ((_a2 = node.tagName) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === "a" && node.hasAttribute("href");
}
function hasHTML(transfer) {
  return transfer.types.includes("text/html");
}
function linkify(element, label) {
  const url = element.href || "";
  let markdown2 = "";
  if (isUserMention(element) || isTeamMention(element)) {
    markdown2 = label;
  } else if (isSpecialLink(element) || areEqualLinks(url, label)) {
    markdown2 = url;
  } else {
    markdown2 = `[${label}](${url})`;
  }
  return markdown2;
}
function isSpecialLink(link) {
  return link.className.indexOf("commit-link") >= 0 || !!link.getAttribute("data-hovercard-type") && link.getAttribute("data-hovercard-type") !== "user";
}
function areEqualLinks(link1, link2) {
  link1 = link1.slice(-1) === "/" ? link1.slice(0, -1) : link1;
  link2 = link2.slice(-1) === "/" ? link2.slice(0, -1) : link2;
  return link1.toLowerCase() === link2.toLowerCase();
}
function isUserMention(link) {
  var _a2;
  return ((_a2 = link.textContent) === null || _a2 === void 0 ? void 0 : _a2.slice(0, 1)) === "@" && link.getAttribute("data-hovercard-type") === "user";
}
function isTeamMention(link) {
  var _a2;
  return ((_a2 = link.textContent) === null || _a2 === void 0 ? void 0 : _a2.slice(0, 1)) === "@" && link.getAttribute("data-hovercard-type") === "team";
}

// node_modules/@github/paste-markdown/dist/paste-markdown-image-link.js
function install2(el) {
  el.addEventListener("dragover", onDragover);
  el.addEventListener("drop", onDrop);
  el.addEventListener("paste", onPaste2);
}
function uninstall3(el) {
  el.removeEventListener("dragover", onDragover);
  el.removeEventListener("drop", onDrop);
  el.removeEventListener("paste", onPaste2);
}
function onDrop(event) {
  const transfer = event.dataTransfer;
  if (!transfer)
    return;
  if (hasFile(transfer))
    return;
  if (!hasLink(transfer))
    return;
  const links = extractLinks(transfer);
  if (!links.some(isImageLink))
    return;
  event.stopPropagation();
  event.preventDefault();
  const field = event.currentTarget;
  if (!(field instanceof HTMLTextAreaElement))
    return;
  insertText2(field, links.map(linkify2).join(""));
}
function onDragover(event) {
  const transfer = event.dataTransfer;
  if (transfer)
    transfer.dropEffect = "link";
}
function onPaste2(event) {
  const { currentTarget: el } = event;
  if (shouldSkipFormatting(el))
    return;
  const transfer = event.clipboardData;
  if (!transfer || !hasLink(transfer))
    return;
  const links = extractLinks(transfer);
  if (!links.some(isImageLink))
    return;
  event.stopPropagation();
  event.preventDefault();
  const field = event.currentTarget;
  if (!(field instanceof HTMLTextAreaElement))
    return;
  insertText2(field, links.map(linkify2).join(""));
}
function linkify2(link) {
  return isImageLink(link) ? `
![](${link})
` : link;
}
function hasFile(transfer) {
  return Array.from(transfer.types).indexOf("Files") >= 0;
}
function hasLink(transfer) {
  return Array.from(transfer.types).indexOf("text/uri-list") >= 0;
}
function extractLinks(transfer) {
  return (transfer.getData("text/uri-list") || "").split("\r\n");
}
var IMAGE_RE = /\.(gif|png|jpe?g)$/i;
function isImageLink(url) {
  return IMAGE_RE.test(url);
}

// node_modules/@github/paste-markdown/dist/paste-markdown-link.js
var pasteLinkAsPlainTextOverSelectedTextMap = /* @__PURE__ */ new WeakMap();
function install3(el, optionConfig) {
  var _a2;
  pasteLinkAsPlainTextOverSelectedTextMap.set(el, ((_a2 = optionConfig === null || optionConfig === void 0 ? void 0 : optionConfig.defaultPlainTextPaste) === null || _a2 === void 0 ? void 0 : _a2.urlLinks) === true);
  el.addEventListener("paste", onPaste3);
}
function uninstall4(el) {
  el.removeEventListener("paste", onPaste3);
}
function onPaste3(event) {
  var _a2;
  const { currentTarget: el } = event;
  const element = el;
  const shouldPasteAsPlainText = (_a2 = pasteLinkAsPlainTextOverSelectedTextMap.get(element)) !== null && _a2 !== void 0 ? _a2 : false;
  const shouldSkipDefaultBehavior = shouldSkipFormatting(element);
  if (!shouldPasteAsPlainText && shouldSkipDefaultBehavior || shouldPasteAsPlainText && !shouldSkipDefaultBehavior) {
    return;
  }
  const transfer = event.clipboardData;
  if (!transfer || !hasPlainText(transfer))
    return;
  const field = event.currentTarget;
  if (!(field instanceof HTMLTextAreaElement))
    return;
  const text = transfer.getData("text/plain");
  if (!text)
    return;
  if (!isURL(text))
    return;
  if (isWithinLink(field))
    return;
  const selectedText = field.value.substring(field.selectionStart, field.selectionEnd);
  if (!selectedText.length)
    return;
  if (isURL(selectedText.trim()))
    return;
  event.stopPropagation();
  event.preventDefault();
  insertText2(field, linkify3(selectedText, text.trim()));
}
function hasPlainText(transfer) {
  return Array.from(transfer.types).includes("text/plain");
}
function isWithinLink(textarea) {
  const selectionStart = textarea.selectionStart || 0;
  if (selectionStart > 1) {
    const previousChars = textarea.value.substring(selectionStart - 2, selectionStart);
    return previousChars === "](";
  } else {
    return false;
  }
}
function linkify3(selectedText, text) {
  return `[${selectedText}](${text})`;
}
function isURL(url) {
  try {
    const parsedURL = new URL(url);
    return removeTrailingSlash(parsedURL.href).trim() === removeTrailingSlash(url).trim();
  } catch (_a2) {
    return false;
  }
}
function removeTrailingSlash(url) {
  return url.endsWith("/") ? url.slice(0, url.length - 1) : url;
}

// node_modules/@github/paste-markdown/dist/paste-markdown-table.js
function install4(el) {
  el.addEventListener("dragover", onDragover2);
  el.addEventListener("drop", onDrop2);
  el.addEventListener("paste", onPaste4);
}
function uninstall5(el) {
  el.removeEventListener("dragover", onDragover2);
  el.removeEventListener("drop", onDrop2);
  el.removeEventListener("paste", onPaste4);
}
function onDrop2(event) {
  const transfer = event.dataTransfer;
  if (!transfer)
    return;
  if (hasFile2(transfer))
    return;
  const textToPaste = generateText(transfer);
  if (!textToPaste)
    return;
  event.stopPropagation();
  event.preventDefault();
  const field = event.currentTarget;
  if (field instanceof HTMLTextAreaElement) {
    insertText2(field, textToPaste);
  }
}
function onDragover2(event) {
  const transfer = event.dataTransfer;
  if (transfer)
    transfer.dropEffect = "copy";
}
function onPaste4(event) {
  const { currentTarget: el } = event;
  if (shouldSkipFormatting(el))
    return;
  if (!event.clipboardData)
    return;
  const textToPaste = generateText(event.clipboardData);
  if (!textToPaste)
    return;
  event.stopPropagation();
  event.preventDefault();
  const field = event.currentTarget;
  if (field instanceof HTMLTextAreaElement) {
    insertText2(field, textToPaste);
  }
}
function hasFile2(transfer) {
  return Array.from(transfer.types).indexOf("Files") >= 0;
}
function columnText(column) {
  const noBreakSpace = "";
  const text = (column.textContent || "").trim().replace(/\|/g, "\\|").replace(/\n/g, " ");
  return text || noBreakSpace;
}
function tableHeaders(row) {
  return Array.from(row.querySelectorAll("td, th")).map(columnText);
}
function tableMarkdown(node) {
  const rows = Array.from(node.querySelectorAll("tr"));
  const firstRow = rows.shift();
  if (!firstRow)
    return "";
  const headers = tableHeaders(firstRow);
  const spacers = headers.map(() => "--");
  const header = `${headers.join(" | ")}
${spacers.join(" | ")}
`;
  const body = rows.map((row) => {
    return Array.from(row.querySelectorAll("td")).map(columnText).join(" | ");
  }).join("\n");
  return `
${header}${body}

`;
}
function generateText(transfer) {
  if (Array.from(transfer.types).indexOf("text/html") === -1)
    return;
  const html = transfer.getData("text/html");
  if (!/<table/i.test(html))
    return;
  const start = html.substring(0, html.indexOf("<table"));
  const tableCloseIndex = html.lastIndexOf("</table>");
  if (!start || !tableCloseIndex)
    return;
  const end = html.substring(tableCloseIndex + 8);
  const parser = new DOMParser();
  const parsedDocument = parser.parseFromString(html, "text/html");
  let table = parsedDocument.querySelector("table");
  table = !table || table.closest("[data-paste-markdown-skip]") ? null : table;
  if (!table)
    return;
  const formattedTable = tableMarkdown(table);
  if (!formattedTable)
    return;
  return [start, formattedTable, end].join("").replace(/<meta.*?>/, "");
}

// node_modules/@github/paste-markdown/dist/paste-markdown-text.js
function install5(el) {
  el.addEventListener("paste", onPaste5);
}
function uninstall6(el) {
  el.removeEventListener("paste", onPaste5);
}
function onPaste5(event) {
  const { currentTarget: el } = event;
  if (shouldSkipFormatting(el))
    return;
  const transfer = event.clipboardData;
  if (!transfer || !hasMarkdown(transfer))
    return;
  const field = event.currentTarget;
  if (!(field instanceof HTMLTextAreaElement))
    return;
  const text = transfer.getData("text/x-gfm");
  if (!text)
    return;
  event.stopPropagation();
  event.preventDefault();
  insertText2(field, text);
}
function hasMarkdown(transfer) {
  return Array.from(transfer.types).indexOf("text/x-gfm") >= 0;
}

// node_modules/@github/paste-markdown/dist/index.js
function subscribe(el, optionConfig) {
  installAround(el, [install4, install2, install3, install5, install], optionConfig);
  return {
    unsubscribe: () => {
      uninstall(el);
      uninstall5(el);
      uninstall2(el);
      uninstall3(el);
      uninstall4(el);
      uninstall6(el);
    }
  };
}

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_MarkdownInput.js
var import_react35 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/hooks/useDynamicTextareaHeight.js
var import_react31 = __toESM(require_react());
var useDynamicTextareaHeight = ({
  disabled,
  minHeightLines,
  maxHeightLines,
  elementRef,
  value
}) => {
  const [height, setHeight] = (0, import_react31.useState)(void 0);
  const [minHeight, setMinHeight] = (0, import_react31.useState)(void 0);
  const [maxHeight, setMaxHeight] = (0, import_react31.useState)(void 0);
  const refreshHeight = (0, import_react31.useCallback)(() => {
    if (disabled) return;
    const element = elementRef.current;
    if (!element) return;
    const computedStyles = getComputedStyle(element);
    const pt = computedStyles.paddingTop;
    element.style.paddingTop = "0";
    const lastCharacterCoords = getCharacterCoordinates(element, element.value.length);
    setHeight(`${lastCharacterCoords.top + lastCharacterCoords.height + 1}px`);
    element.style.paddingTop = pt;
    const lineHeight = computedStyles.lineHeight === "normal" ? `1.2 * ${computedStyles.fontSize}` : computedStyles.lineHeight;
    if (minHeightLines !== void 0) setMinHeight(`calc(${minHeightLines} * ${lineHeight})`);
    if (maxHeightLines !== void 0) setMaxHeight(`calc(${maxHeightLines} * ${lineHeight})`);
  }, [minHeightLines, maxHeightLines, value, elementRef, disabled]);
  useIsomorphicLayoutEffect(refreshHeight, [refreshHeight]);
  (0, import_react31.useEffect)(refreshHeight, []);
  if (disabled) return {};
  return {
    height,
    minHeight,
    maxHeight,
    boxSizing: "content-box"
  };
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/suggestions/_useEmojiSuggestions.js
var import_react32 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/suggestions/index.js
var MAX_SUGGESTIONS = 5;
var suggestionsCalculator = (options, score2, toSuggestion) => async (query) => {
  if (options === "loading") return "loading";
  const optionsArray = Array.isArray(options) ? options : await options();
  const scoredAndSorted = query ? optionsArray.map((o) => [score2(query, o), o]).filter(([s]) => s > 0).sort(([a], [b]) => b - a).slice(0, MAX_SUGGESTIONS).map(([, o]) => o) : optionsArray.slice(0, MAX_SUGGESTIONS);
  return scoredAndSorted.map(toSuggestion);
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/suggestions/_useEmojiSuggestions.js
var trigger = {
  triggerChar: ":",
  keepTriggerCharOnCommit: false
};
var emojiToSugggestion = (emoji) => ({
  value: "character" in emoji ? emoji.character : `:${emoji.name}:`,
  key: emoji.name,
  // emoji characters may not be unique - ie haircut and haircut_man both have the same emoji codepoint. But names are guaranteed to be unique.
  render: (props) => import_react32.default.createElement(ActionList.Item, props, import_react32.default.createElement(ActionList.LeadingVisual, null, "character" in emoji ? emoji.character : import_react32.default.createElement("img", {
    src: emoji.url,
    alt: `${emoji.name} emoji`,
    height: "16",
    width: "16"
  })), emoji.name)
});
var scoreSuggestion = (query, emoji) => {
  const name = emoji.name.toLowerCase();
  const q = query.toLowerCase();
  let score2 = 0;
  if (name.includes(q)) {
    score2 += 5;
    if (name.startsWith(q)) score2 += 5;
  }
  return score2;
};
var useEmojiSuggestions = (emojis) => {
  const calculateSuggestions = (0, import_react32.useMemo)(() => suggestionsCalculator(emojis, scoreSuggestion, emojiToSugggestion), [emojis]);
  return {
    calculateSuggestions,
    trigger
  };
};

// node_modules/fzy.js/index.js
var SCORE_MIN = -Infinity;
var SCORE_MAX = Infinity;
var SCORE_GAP_LEADING = -5e-3;
var SCORE_GAP_TRAILING = -5e-3;
var SCORE_GAP_INNER = -0.01;
var SCORE_MATCH_CONSECUTIVE = 1;
var SCORE_MATCH_SLASH = 0.9;
var SCORE_MATCH_WORD = 0.8;
var SCORE_MATCH_CAPITAL = 0.7;
var SCORE_MATCH_DOT = 0.6;
function islower(s) {
  return s.toLowerCase() === s;
}
function isupper(s) {
  return s.toUpperCase() === s;
}
function precompute_bonus(haystack) {
  var m = haystack.length;
  var match_bonus = new Array(m);
  var last_ch = "/";
  for (var i = 0; i < m; i++) {
    var ch = haystack[i];
    if (last_ch === "/") {
      match_bonus[i] = SCORE_MATCH_SLASH;
    } else if (last_ch === "-" || last_ch === "_" || last_ch === " ") {
      match_bonus[i] = SCORE_MATCH_WORD;
    } else if (last_ch === ".") {
      match_bonus[i] = SCORE_MATCH_DOT;
    } else if (islower(last_ch) && isupper(ch)) {
      match_bonus[i] = SCORE_MATCH_CAPITAL;
    } else {
      match_bonus[i] = 0;
    }
    last_ch = ch;
  }
  return match_bonus;
}
function compute(needle, haystack, D, M) {
  var n = needle.length;
  var m = haystack.length;
  var lower_needle = needle.toLowerCase();
  var lower_haystack = haystack.toLowerCase();
  var match_bonus = precompute_bonus(haystack, match_bonus);
  for (var i = 0; i < n; i++) {
    D[i] = new Array(m);
    M[i] = new Array(m);
    var prev_score = SCORE_MIN;
    var gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;
    for (var j = 0; j < m; j++) {
      if (lower_needle[i] === lower_haystack[j]) {
        var score2 = SCORE_MIN;
        if (!i) {
          score2 = j * SCORE_GAP_LEADING + match_bonus[j];
        } else if (j) {
          score2 = Math.max(
            M[i - 1][j - 1] + match_bonus[j],
            /* consecutive match, doesn't stack with match_bonus */
            D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE
          );
        }
        D[i][j] = score2;
        M[i][j] = prev_score = Math.max(score2, prev_score + gap_score);
      } else {
        D[i][j] = SCORE_MIN;
        M[i][j] = prev_score = prev_score + gap_score;
      }
    }
  }
}
function score(needle, haystack) {
  var n = needle.length;
  var m = haystack.length;
  if (!n || !m)
    return SCORE_MIN;
  if (n === m) {
    return SCORE_MAX;
  }
  if (m > 1024) {
    return SCORE_MIN;
  }
  var D = new Array(n);
  var M = new Array(n);
  compute(needle, haystack, D, M);
  return M[n - 1][m - 1];
}

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/suggestions/_useMentionSuggestions.js
var import_react33 = __toESM(require_react());
var trigger2 = {
  triggerChar: "@"
};
var mentionableToSuggestion = (mentionable) => ({
  value: mentionable.identifier,
  render: (props) => import_react33.default.createElement(ActionList.Item, props, import_react33.default.createElement(Text, {
    sx: {
      fontWeight: "bold"
    }
  }, mentionable.identifier), " ", import_react33.default.createElement(ActionList.Description, null, mentionable.description))
});
var scoreSuggestion2 = (query, mentionable) => {
  const fzyScore = score(query, `${mentionable.identifier} ${mentionable.description}`.trim().toLowerCase());
  if (fzyScore === Infinity && query.toLowerCase() !== mentionable.identifier.toLowerCase()) return -Infinity;
  return fzyScore;
};
var useMentionSuggestions = (mentionables) => {
  const calculateSuggestions = (0, import_react33.useMemo)(() => suggestionsCalculator(mentionables, scoreSuggestion2, mentionableToSuggestion), [mentionables]);
  return {
    calculateSuggestions,
    trigger: trigger2
  };
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/suggestions/_useReferenceSuggestions.js
var import_react34 = __toESM(require_react());
var trigger3 = {
  triggerChar: "#",
  multiWord: true
};
var referenceToSuggestion = (reference) => ({
  value: reference.id,
  render: (props) => import_react34.default.createElement(ActionList.Item, props, reference.iconHtml && import_react34.default.createElement(ActionList.LeadingVisual, null, import_react34.default.createElement("span", {
    dangerouslySetInnerHTML: {
      __html: reference.iconHtml
    }
  })), import_react34.default.createElement(Text, {
    sx: {
      fontWeight: "bold",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      display: "block",
      overflow: "hidden",
      maxWidth: 400
    }
  }, import_react34.default.createElement("span", {
    dangerouslySetInnerHTML: {
      __html: reference.titleHtml
    }
  })), " ", import_react34.default.createElement(ActionList.Description, null, "#", reference.id))
});
var scoreSuggestion3 = (query, reference) => {
  const fzyScore = score(query, `${reference.id} ${reference.titleText}`);
  return fzyScore === Infinity ? -Infinity : fzyScore;
};
var useReferenceSuggestions = (references) => {
  const calculateSuggestions = (0, import_react34.useMemo)(() => {
    const calculator = suggestionsCalculator(references, scoreSuggestion3, referenceToSuggestion);
    return async (query) => {
      if (/^\d+\s/.test(query)) return [];
      return calculator(query);
    };
  }, [references]);
  return {
    calculateSuggestions,
    trigger: trigger3
  };
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_MarkdownInput.js
function _extends9() {
  return _extends9 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends9.apply(null, arguments);
}
var emptyArray = [];
var MarkdownInput = (0, import_react35.forwardRef)(({
  value,
  onChange,
  disabled,
  placeholder: placeholder2,
  id,
  maxLength,
  onKeyDown,
  fullHeight,
  isDraggedOver,
  emojiSuggestions,
  mentionSuggestions,
  referenceSuggestions,
  minHeightLines,
  maxHeightLines,
  visible: visible2,
  monospace,
  pasteUrlsAsPlainText,
  ...props
}, forwardedRef) => {
  const [suggestions, setSuggestions] = (0, import_react35.useState)(null);
  const [event, setEvent] = (0, import_react35.useState)(null);
  const {
    trigger: emojiTrigger,
    calculateSuggestions: calculateEmojiSuggestions
  } = useEmojiSuggestions(emojiSuggestions !== null && emojiSuggestions !== void 0 ? emojiSuggestions : emptyArray);
  const {
    trigger: mentionsTrigger,
    calculateSuggestions: calculateMentionSuggestions
  } = useMentionSuggestions(mentionSuggestions !== null && mentionSuggestions !== void 0 ? mentionSuggestions : emptyArray);
  const {
    trigger: referencesTrigger,
    calculateSuggestions: calculateReferenceSuggestions
  } = useReferenceSuggestions(referenceSuggestions !== null && referenceSuggestions !== void 0 ? referenceSuggestions : emptyArray);
  const triggers = (0, import_react35.useMemo)(() => [mentionsTrigger, referencesTrigger, emojiTrigger], [mentionsTrigger, referencesTrigger, emojiTrigger]);
  const lastEventRef = (0, import_react35.useRef)(null);
  const onHideSuggestions = () => {
    setEvent(null);
    setSuggestions(null);
  };
  (0, import_react35.useEffect)(() => {
    if (!event) {
      setSuggestions(null);
      return;
    }
    (async function() {
      lastEventRef.current = event;
      setSuggestions("loading");
      if (event.trigger.triggerChar === emojiTrigger.triggerChar) {
        setSuggestions(await calculateEmojiSuggestions(event.query));
      } else if (event.trigger.triggerChar === mentionsTrigger.triggerChar) {
        setSuggestions(await calculateMentionSuggestions(event.query));
      } else if (event.trigger.triggerChar === referencesTrigger.triggerChar) {
        setSuggestions(await calculateReferenceSuggestions(event.query));
      }
    })();
  }, [
    event,
    calculateEmojiSuggestions,
    calculateMentionSuggestions,
    calculateReferenceSuggestions,
    // The triggers never actually change because they are statically defined
    emojiTrigger,
    mentionsTrigger,
    referencesTrigger
  ]);
  const ref = (0, import_react35.useRef)(null);
  useRefObjectAsForwardedRef(forwardedRef, ref);
  (0, import_react35.useEffect)(() => {
    const subscription = ref.current && subscribe(ref.current, {
      defaultPlainTextPaste: {
        urlLinks: pasteUrlsAsPlainText
      }
    });
    return subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe;
  }, [pasteUrlsAsPlainText]);
  const heightStyles = useDynamicTextareaHeight({
    // if fullHeight is enabled, there is no need to compute a dynamic height (for perfs reasons)
    disabled: fullHeight,
    maxHeightLines,
    minHeightLines,
    elementRef: ref,
    value
  });
  return import_react35.default.createElement(InlineAutocomplete, {
    triggers,
    suggestions,
    onShowSuggestions: setEvent,
    onHideSuggestions,
    sx: {
      flex: "auto"
    },
    tabInsertsSuggestions: true
  }, import_react35.default.createElement(Textarea, _extends9({
    id,
    ref,
    placeholder: placeholder2,
    maxLength,
    value,
    onKeyDown,
    disabled,
    "aria-label": "Markdown value",
    onChange,
    sx: {
      borderStyle: "none",
      boxShadow: "none",
      height: fullHeight ? "100%" : void 0,
      outline: (theme) => {
        return isDraggedOver ? `dashed 2px ${theme.colors.border.muted}` : void 0;
      },
      outlineOffset: "-4px",
      display: visible2 ? void 0 : "none",
      "&: focus-within": {
        boxShadow: "none",
        outline: "none"
      },
      "& textarea": {
        lineHeight: "var(--text-body-lineHeight-medium, 1.4285)",
        resize: fullHeight ? "none" : "vertical",
        p: 3,
        fontFamily: monospace ? "mono" : "normal",
        ...heightStyles
      }
    }
  }, props)));
});
MarkdownInput.displayName = "MarkdownInput";

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_ViewSwitch.js
var import_react36 = __toESM(require_react());
function _extends10() {
  return _extends10 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends10.apply(null, arguments);
}
var ViewSwitch = ({
  selectedView,
  onViewSelect,
  onLoadPreview,
  disabled
}) => {
  const sharedProps = selectedView === "preview" ? {
    onClick: () => onViewSelect === null || onViewSelect === void 0 ? void 0 : onViewSelect("edit")
  } : {
    onClick: () => {
      onLoadPreview();
      onViewSelect === null || onViewSelect === void 0 ? void 0 : onViewSelect("preview");
    },
    onMouseOver: () => onLoadPreview(),
    onFocus: () => onLoadPreview()
  };
  return import_react36.default.createElement(Box, {
    sx: {
      display: "flex",
      flexDirection: "row"
    }
  }, import_react36.default.createElement(TabNav$1, {
    "aria-label": "View mode"
  }, import_react36.default.createElement(TabNav$1.Link, _extends10({}, sharedProps, {
    as: "button",
    selected: selectedView === "edit",
    disabled,
    sx: {
      cursor: "pointer",
      color: selectedView === "edit" ? "fg.default" : "fg.muted",
      borderTopLeftRadius: 1
    }
  }), "Write"), import_react36.default.createElement(TabNav$1.Link, _extends10({}, sharedProps, {
    as: "button",
    selected: selectedView === "preview",
    disabled,
    sx: {
      cursor: "pointer",
      color: selectedView === "preview" ? "fg.default" : "fg.muted",
      borderTopLeftRadius: 1
    }
  }), "Preview")));
};
ViewSwitch.displayName = "ViewSwitch";

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_useFileHandling.js
var import_react38 = __toESM(require_react());

// node_modules/@primer/react/lib-esm/drafts/hooks/useUnifiedFileSelect.js
var import_react37 = __toESM(require_react());
var fileTypeMatcher = (fileType) => {
  if (fileType.startsWith(".")) {
    return (file) => file.name.toLowerCase().endsWith(fileType.toLowerCase());
  } else {
    const mimeTypeMatch = fileType.match(mimeTypeRegex);
    if (mimeTypeMatch === null) return () => false;
    const [, targetType, targetSubtype] = mimeTypeMatch;
    return (file) => {
      var _file$type$match;
      const [, type, subType] = (_file$type$match = file.type.match(mimeTypeRegex)) !== null && _file$type$match !== void 0 ? _file$type$match : [];
      return targetType.toLowerCase() === type.toLowerCase() && (targetSubtype === "*" || targetSubtype.toLowerCase() === subType.toLowerCase());
    };
  }
};
function useOnSelectFiles(props) {
  const matchers = (0, import_react37.useMemo)(() => {
    var _props$acceptedFileTy;
    return (_props$acceptedFileTy = props.acceptedFileTypes) === null || _props$acceptedFileTy === void 0 ? void 0 : _props$acceptedFileTy.map(fileTypeMatcher);
  }, [props.acceptedFileTypes]);
  const isAcceptableFile = (0, import_react37.useCallback)((file) => {
    var _matchers$some;
    return (_matchers$some = matchers === null || matchers === void 0 ? void 0 : matchers.some((m) => m(file))) !== null && _matchers$some !== void 0 ? _matchers$some : true;
  }, [matchers]);
  return (0, import_react37.useCallback)(
    function onSelectFiles(files) {
      if (files.length === 0) return false;
      if (props.multi) {
        const accepted = [];
        const rejected = [];
        for (const file of files) isAcceptableFile(file) ? accepted.push(file) : rejected.push(file);
        props.onSelect(accepted, rejected);
      } else {
        const file = files[0];
        if (isAcceptableFile(file)) props.onSelect(file, void 0);
        else props.onSelect(void 0, file);
      }
      return true;
    },
    // Because props is a discriminated union type, eslint isn't smart enough to realize we
    // are putting all used properties in the dependency array. We can't use destructuring
    // to extract them or we'll lose the type link between multi & onSelect
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [isAcceptableFile, props.multi, props.onSelect]
  );
}
var mimeTypeRegex = /([^/]+)\/([^;]);?(.*)/;
function useUnifiedFileSelect(props) {
  const clickTargetProps = useClickFileSelect(props);
  const pasteTargetProps = usePasteFileSelect(props);
  const [isDraggedOver, dropTargetProps] = useDropFileSelect(props);
  return (0, import_react37.useMemo)(() => ({
    clickTargetProps,
    pasteTargetProps,
    dropTargetProps,
    isDraggedOver
  }), [clickTargetProps, dropTargetProps, isDraggedOver, pasteTargetProps]);
}
function useClickFileSelect(props) {
  const onSelectFiles = useOnSelectFiles(props);
  const {
    multi,
    acceptedFileTypes
  } = props;
  const fileInputRef = (0, import_react37.useRef)(null);
  const onInputChange = (0, import_react37.useCallback)(function onChange() {
    if (this.files) onSelectFiles(this.files);
  }, [onSelectFiles]);
  (0, import_react37.useEffect)(function createFileInputClickTarget() {
    const fileInput = document.createElement("input");
    fileInput.setAttribute("type", "file");
    fileInput.setAttribute("multiple", multi ? "true" : "false");
    if (acceptedFileTypes) fileInput.setAttribute("accept", acceptedFileTypes.join(", "));
    fileInput.style.display = "none";
    fileInput.addEventListener("change", onInputChange);
    document.body.appendChild(fileInput);
    fileInputRef.current = fileInput;
    return () => {
      var _fileInput$parentNode;
      fileInputRef.current = null;
      (_fileInput$parentNode = fileInput.parentNode) === null || _fileInput$parentNode === void 0 ? void 0 : _fileInput$parentNode.removeChild(fileInput);
    };
  }, [multi, acceptedFileTypes, onInputChange]);
  const onClick = (0, import_react37.useCallback)(() => {
    var _fileInputRef$current;
    return (_fileInputRef$current = fileInputRef.current) === null || _fileInputRef$current === void 0 ? void 0 : _fileInputRef$current.click();
  }, []);
  return (0, import_react37.useMemo)(() => ({
    onClick
  }), [onClick]);
}
var isFileDragEvent = (event) => Array.from(event.dataTransfer.items).some(({
  kind
}) => kind === "file");
function useDropFileSelect(props) {
  const onSelectFiles = useOnSelectFiles(props);
  const [isDraggedOver, setIsDraggedOver] = (0, import_react37.useState)(false);
  const onDragLeave = (0, import_react37.useCallback)(() => setIsDraggedOver(false), []);
  const onDragEnter = (0, import_react37.useCallback)((event) => {
    if (!isFileDragEvent(event)) return;
    setIsDraggedOver(true);
    event.preventDefault();
  }, []);
  const onDragOver = (0, import_react37.useCallback)((event) => {
    if (!isFileDragEvent(event)) return;
    event.preventDefault();
    event.dataTransfer.dropEffect = "link";
  }, []);
  const onDrop3 = (0, import_react37.useCallback)((event) => {
    if (onSelectFiles(event.dataTransfer.files)) {
      event.preventDefault();
      setIsDraggedOver(false);
    }
  }, [onSelectFiles]);
  const dropTargetProps = (0, import_react37.useMemo)(() => ({
    onDragEnter,
    onDragOver,
    onDragLeave,
    onDrop: onDrop3
    // onDragStart and onDragEnd are not relevant for system file dragging
  }), [onDrop3, onDragOver, onDragLeave, onDragEnter]);
  return [isDraggedOver, dropTargetProps];
}
function usePasteFileSelect(props) {
  const onSelectFiles = useOnSelectFiles(props);
  return (0, import_react37.useMemo)(() => ({
    onPaste: (event) => {
      if (onSelectFiles(event.clipboardData.files)) {
        event.preventDefault();
      }
    }
  }), [onSelectFiles]);
}

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_useFileHandling.js
var placeholder = (file) => markdownComment(`Uploading "${file.name}"...`);
var markdown = (file, url) => {
  if (!url) return markdownComment(`Failed to upload "${file.name}"`);
  if (file.type.startsWith("video/")) return url;
  if (file.type.startsWith("image/")) return markdownImage("Image", url);
  return markdownLink(file.name, url);
};
var noop2 = () => {
};
var useFileHandling = ({
  emitChange,
  value,
  inputRef,
  disabled,
  onUploadFile,
  acceptedFileTypes
}) => {
  const [errorMessage, setErrorMessage] = (0, import_react38.useState)(void 0);
  const errorVisibleForEnoughTime = (0, import_react38.useRef)(false);
  (0, import_react38.useEffect)(() => {
    if (errorMessage) {
      errorVisibleForEnoughTime.current = false;
      const id = setTimeout(() => errorVisibleForEnoughTime.current = true, 1e3);
      return () => clearTimeout(id);
    }
  }, [errorMessage]);
  (0, import_react38.useEffect)(() => {
    if (errorVisibleForEnoughTime.current) setErrorMessage(void 0);
  }, [value]);
  const safeSetRejectedFiles = useSafeAsyncCallback((files) => {
    const types = new Set(files.map(({
      name
    }) => {
      const parts = name.split(".");
      return parts.length > 1 ? `.${parts.at(-1)}` : "";
    }).filter((s) => s !== ""));
    if (types.size > 0) setErrorMessage(`File type${types.size > 1 ? "s" : ""} not allowed: ${[...types].join(", ")}`);
  });
  const [uploadProgress, setUploadProgress] = (0, import_react38.useState)(void 0);
  const safeClearUploadProgress = useSafeAsyncCallback(() => setUploadProgress(void 0));
  const insertPlaceholder = (0, import_react38.useCallback)((files) => {
    if (!inputRef.current) return;
    const placeholders = `

${files.map(placeholder).join("\n")}

`;
    emitChange(placeholders);
  }, [inputRef, emitChange]);
  const replacePlaceholderWithMarkdown = (file, url) => {
    if (!inputRef.current) return;
    const placeholderStr = placeholder(file);
    const placeholderIndex = inputRef.current.value.indexOf(placeholderStr);
    if (placeholderIndex === -1) return;
    emitChange(markdown(file, url), [placeholderIndex, placeholderIndex + placeholderStr.length]);
  };
  const safeHandleCompletedFileUpload = useSafeAsyncCallback(({
    file,
    url
  }) => {
    setUploadProgress((progress) => progress && [progress[0] + 1, progress[1]]);
    replacePlaceholderWithMarkdown(file, url);
  });
  const uploadFiles = (0, import_react38.useCallback)((files) => files.map(async (file) => {
    let result = {
      url: null,
      file
    };
    try {
      var _await$onUploadFile;
      result = (_await$onUploadFile = await (onUploadFile === null || onUploadFile === void 0 ? void 0 : onUploadFile(file))) !== null && _await$onUploadFile !== void 0 ? _await$onUploadFile : {
        file,
        url: null
      };
    } catch (e) {
      result = {
        file,
        url: null
      };
    }
    safeHandleCompletedFileUpload(result);
  }), [onUploadFile, safeHandleCompletedFileUpload]);
  const onSelectFiles = (0, import_react38.useCallback)(async (accepted, rejected) => {
    if (accepted.length > 0) {
      setUploadProgress([1, accepted.length]);
      insertPlaceholder(accepted);
      await Promise.all(uploadFiles(accepted));
      safeClearUploadProgress();
    }
    safeSetRejectedFiles(rejected);
  }, [safeSetRejectedFiles, insertPlaceholder, uploadFiles, safeClearUploadProgress]);
  let fileSelect = useUnifiedFileSelect({
    acceptedFileTypes,
    multi: true,
    onSelect: onSelectFiles
  });
  if (disabled) {
    fileSelect = {
      clickTargetProps: {
        onClick: noop2
      },
      dropTargetProps: {
        onDragEnter: noop2,
        onDragLeave: noop2,
        onDrop: noop2,
        onDragOver: noop2
      },
      pasteTargetProps: {
        onPaste: noop2
      },
      isDraggedOver: false
    };
  }
  return onUploadFile ? {
    ...fileSelect,
    errorMessage,
    uploadProgress
  } : null;
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_useIndenting.js
var import_react39 = __toESM(require_react());
var indentationRegex = /^(?:\t| ? ?)(.*)/;
var dedent = (line) => {
  var _indentationRegex$exe, _indentationRegex$exe2;
  return (_indentationRegex$exe = (_indentationRegex$exe2 = indentationRegex.exec(line)) === null || _indentationRegex$exe2 === void 0 ? void 0 : _indentationRegex$exe2[1]) !== null && _indentationRegex$exe !== void 0 ? _indentationRegex$exe : "";
};
var indent = (line) => `  ${line}`;
var useIndenting = ({
  emitChange
}) => {
  const onKeyDown = (0, import_react39.useCallback)((event) => {
    const textarea = event.currentTarget;
    if (event.defaultPrevented || event.key !== "Tab" || textarea.selectionEnd - textarea.selectionStart === 0) return;
    event.preventDefault();
    const [start, end] = getSelectedLineRange(textarea);
    const updatedLines = textarea.value.slice(start, end).split(/\r?\n/).map((line) => event.shiftKey ? dedent(line) : indent(line)).join("\n");
    emitChange(updatedLines, [start, end], [start, start + updatedLines.length]);
  }, [emitChange]);
  return {
    onKeyDown
  };
};

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_ErrorMessage.js
var import_react40 = __toESM(require_react());
var ErrorMessage = (0, import_react40.memo)(({
  message
}) => import_react40.default.createElement(Flash, {
  "aria-live": "polite",
  variant: "danger",
  full: true,
  sx: {
    fontSize: 1,
    borderBottomLeftRadius: 2,
    borderBottomRightRadius: 2,
    px: 2,
    py: 2
  }
}, message));

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/MarkdownEditor.js
function _extends11() {
  return _extends11 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends11.apply(null, arguments);
}
var a11yOnlyStyle = {
  clipPath: "Circle(0)",
  position: "absolute"
};
var CONDENSED_WIDTH_THRESHOLD = 675;
var editorsInPreviewMode = [];
var MarkdownEditor = (0, import_react41.forwardRef)(({
  value,
  onChange,
  disabled = false,
  placeholder: placeholder2,
  maxLength,
  "aria-describedby": describedBy,
  fullHeight,
  onRenderPreview,
  sx: sx2,
  onPrimaryAction,
  viewMode: controlledViewMode,
  onChangeViewMode: controlledSetViewMode,
  minHeightLines = 5,
  maxHeightLines = 35,
  emojiSuggestions,
  mentionSuggestions,
  referenceSuggestions,
  onUploadFile,
  acceptedFileTypes,
  monospace = false,
  required = false,
  name,
  children,
  savedReplies,
  pasteUrlsAsPlainText = false
}, ref) => {
  var _slots$toolbar, _fileHandler$isDragge2, _slots$footer;
  const [slots, childrenWithoutSlots] = useSlots(children, {
    toolbar: Toolbar,
    actions: Actions,
    label: Label,
    footer: Footer
  });
  const [uncontrolledViewMode, uncontrolledSetViewMode] = (0, import_react41.useState)("edit");
  const [view, setView] = controlledViewMode === void 0 ? [uncontrolledViewMode, uncontrolledSetViewMode] : [controlledViewMode, controlledSetViewMode];
  const [html, setHtml] = (0, import_react41.useState)(null);
  const safeSetHtml = useSafeAsyncCallback(setHtml);
  const previewStale = (0, import_react41.useRef)(true);
  (0, import_react41.useEffect)(() => {
    previewStale.current = true;
  }, [value]);
  const loadPreview = async () => {
    if (!previewStale.current) return;
    previewStale.current = false;
    safeSetHtml(null);
    safeSetHtml(await onRenderPreview(value));
  };
  (0, import_react41.useEffect)(() => {
    if (view === "preview" && previewStale.current) loadPreview();
  });
  const inputRef = (0, import_react41.useRef)(null);
  (0, import_react41.useImperativeHandle)(ref, () => ({
    focus: (opts) => {
      var _inputRef$current;
      return (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus(opts);
    },
    scrollIntoView: (opts) => {
      var _containerRef$current;
      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.scrollIntoView(opts);
    }
  }));
  const inputHeight = (0, import_react41.useRef)(0);
  if (inputRef.current && inputRef.current.offsetHeight) inputHeight.current = inputRef.current.offsetHeight;
  const onInputChange = (0, import_react41.useCallback)((e) => {
    onChange(e.target.value);
  }, [onChange]);
  const emitChange = useSyntheticChange({
    inputRef,
    fallbackEventHandler: onInputChange
  });
  const fileHandler = useFileHandling({
    emitChange,
    value,
    inputRef,
    disabled,
    onUploadFile,
    acceptedFileTypes
  });
  const listEditor = useListEditing({
    emitChange
  });
  const indenter = useIndenting({
    emitChange
  });
  const formattingToolsRef = (0, import_react41.useRef)(null);
  const containerRef = (0, import_react41.useRef)(null);
  const [condensed, setCondensed] = (0, import_react41.useState)(false);
  const onResize = (0, import_react41.useCallback)(
    // it's fine that this isn't debounced because calling setCondensed with the current value will not trigger a render
    () => setCondensed(containerRef.current !== null && containerRef.current.clientWidth < CONDENSED_WIDTH_THRESHOLD),
    []
  );
  useResizeObserver(onResize, containerRef);
  useIsomorphicLayoutEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    const parent = container.parentElement;
    const nextSibling = containerRef.current.nextSibling;
    parent === null || parent === void 0 ? void 0 : parent.removeChild(container);
    parent === null || parent === void 0 ? void 0 : parent.insertBefore(container, nextSibling);
  }, [condensed]);
  const id = useId();
  const descriptionId = `${id}-description`;
  const savedRepliesRef = (0, import_react41.useRef)(null);
  const onSelectSavedReply = (reply) => {
    requestAnimationFrame(() => emitChange(reply.content));
  };
  const savedRepliesContext = savedReplies ? {
    savedReplies,
    onSelect: onSelectSavedReply,
    ref: savedRepliesRef
  } : null;
  const inputCompositionProps = useIgnoreKeyboardActionsWhileComposing((e) => {
    const format = formattingToolsRef.current;
    if (disabled) return;
    if (e.ctrlKey && e.key === ".") {
      var _savedRepliesRef$curr;
      (_savedRepliesRef$curr = savedRepliesRef.current) === null || _savedRepliesRef$curr === void 0 ? void 0 : _savedRepliesRef$curr.openMenu();
      e.preventDefault();
      e.stopPropagation();
    } else if (isModifierKey(e)) {
      if (e.key === "Enter") onPrimaryAction === null || onPrimaryAction === void 0 ? void 0 : onPrimaryAction();
      else if (e.key === "b") format === null || format === void 0 ? void 0 : format.bold();
      else if (e.key === "i") format === null || format === void 0 ? void 0 : format.italic();
      else if (e.shiftKey && e.key === ".") format === null || format === void 0 ? void 0 : format.quote();
      else if (e.key === "e") format === null || format === void 0 ? void 0 : format.code();
      else if (e.key === "k") format === null || format === void 0 ? void 0 : format.link();
      else if (e.key === "8") format === null || format === void 0 ? void 0 : format.unorderedList();
      else if (e.shiftKey && e.key === "7") format === null || format === void 0 ? void 0 : format.orderedList();
      else if (e.shiftKey && e.key === "l") format === null || format === void 0 ? void 0 : format.taskList();
      else if (e.shiftKey && e.key === "p") setView === null || setView === void 0 ? void 0 : setView("preview");
      else return;
      e.preventDefault();
      e.stopPropagation();
    } else {
      listEditor.onKeyDown(e);
      indenter.onKeyDown(e);
    }
  });
  (0, import_react41.useEffect)(() => {
    if (view === "preview") {
      editorsInPreviewMode.push(id);
      const handler = (e) => {
        if (!e.defaultPrevented && editorsInPreviewMode.at(-1) === id && isModifierKey(e) && e.shiftKey && e.key === "p") {
          setView === null || setView === void 0 ? void 0 : setView("edit");
          setTimeout(() => {
            var _inputRef$current2;
            return (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.focus();
          });
          e.preventDefault();
        }
      };
      document.addEventListener("keydown", handler);
      return () => {
        document.removeEventListener("keydown", handler);
        editorsInPreviewMode = editorsInPreviewMode.filter((id_) => id_ !== id);
      };
    }
  }, [view, setView, id]);
  const context = (0, import_react41.useMemo)(() => {
    var _fileHandler$isDragge, _fileHandler$clickTar;
    return {
      disabled,
      formattingToolsRef,
      condensed,
      required,
      fileDraggedOver: (_fileHandler$isDragge = fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.isDraggedOver) !== null && _fileHandler$isDragge !== void 0 ? _fileHandler$isDragge : false,
      fileUploadProgress: fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.uploadProgress,
      uploadButtonProps: (_fileHandler$clickTar = fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.clickTargetProps) !== null && _fileHandler$clickTar !== void 0 ? _fileHandler$clickTar : null,
      errorMessage: fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.errorMessage,
      previewMode: view === "preview"
    };
  }, [disabled, condensed, required, fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.isDraggedOver, fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.uploadProgress, fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.clickTargetProps, fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.errorMessage, view]);
  return import_react41.default.createElement(MarkdownEditorContext.Provider, {
    value: context
  }, import_react41.default.createElement("fieldset", {
    "aria-disabled": disabled,
    "aria-describedby": describedBy ? `${descriptionId} ${describedBy}` : descriptionId,
    style: {
      appearance: "none",
      border: "none",
      minInlineSize: "auto",
      height: fullHeight ? "100%" : void 0
    }
  }, import_react41.default.createElement(FormattingTools, {
    ref: formattingToolsRef,
    forInputId: id
  }), import_react41.default.createElement("div", {
    style: {
      display: "none"
    }
  }, childrenWithoutSlots), slots.label, import_react41.default.createElement(Box, {
    sx: {
      display: "flex",
      flexDirection: "column"
    },
    ref: containerRef
  }, import_react41.default.createElement(Box, {
    sx: {
      display: "flex",
      flexDirection: "column",
      width: "100%",
      borderColor: "border.default",
      borderWidth: 1,
      borderStyle: "solid",
      borderRadius: 2,
      height: fullHeight ? "100%" : void 0,
      minInlineSize: "auto",
      bg: "canvas.default",
      color: disabled ? "fg.subtle" : "fg.default",
      "&: focus-within": view === "edit" ? {
        outline: "2px solid",
        outlineColor: "accent.emphasis",
        outlineOffset: "-1px"
      } : {},
      ...sx2
    }
  }, import_react41.default.createElement(VisuallyHidden2, {
    id: descriptionId,
    "aria-live": "polite"
  }, "Markdown input:", view === "preview" ? " preview mode selected." : " edit mode selected."), import_react41.default.createElement(Box, {
    sx: {
      display: "flex",
      backgroundColor: "canvas.subtle",
      borderTopLeftRadius: 2,
      borderTopRightRadius: 2,
      justifyContent: "space-between"
    },
    as: "header"
  }, import_react41.default.createElement(Box, {
    sx: {
      ml: "-1px",
      mt: "-1px",
      display: "flex",
      alignItems: "flex-end",
      flexGrow: 1,
      flexBasis: 0
    }
  }, import_react41.default.createElement(ViewSwitch, {
    selectedView: view,
    onViewSelect: setView,
    disabled: (fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.uploadProgress) !== void 0,
    onLoadPreview: loadPreview
  }), import_react41.default.createElement(Box, {
    sx: {
      borderBottom: "1px solid",
      borderBottomColor: "border.subtle",
      flexGrow: 1
    }
  })), import_react41.default.createElement(SavedRepliesContext.Provider, {
    value: savedRepliesContext
  }, view === "edit" && ((_slots$toolbar = slots.toolbar) !== null && _slots$toolbar !== void 0 ? _slots$toolbar : import_react41.default.createElement(CoreToolbar, null, import_react41.default.createElement(DefaultToolbarButtons, null))))), import_react41.default.createElement(MarkdownInput, _extends11({
    value,
    onChange: onInputChange,
    emojiSuggestions,
    mentionSuggestions,
    referenceSuggestions,
    disabled,
    placeholder: placeholder2,
    id,
    maxLength,
    ref: inputRef,
    fullHeight,
    isDraggedOver: (_fileHandler$isDragge2 = fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.isDraggedOver) !== null && _fileHandler$isDragge2 !== void 0 ? _fileHandler$isDragge2 : false,
    minHeightLines,
    maxHeightLines,
    visible: view === "edit",
    monospace,
    required,
    name,
    pasteUrlsAsPlainText
  }, inputCompositionProps, fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.pasteTargetProps, fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.dropTargetProps)), view === "edit" && (fileHandler === null || fileHandler === void 0 ? void 0 : fileHandler.errorMessage) && import_react41.default.createElement(ErrorMessage, {
    message: fileHandler.errorMessage
  }), view === "preview" && import_react41.default.createElement(Box, {
    sx: {
      p: 3,
      overflow: "auto",
      height: fullHeight ? "100%" : void 0,
      minHeight: inputHeight.current,
      boxSizing: "border-box"
    },
    "aria-live": "polite",
    tabIndex: -1
  }, import_react41.default.createElement("h2", {
    style: a11yOnlyStyle
  }, "Rendered Markdown Preview"), import_react41.default.createElement(MarkdownViewer, {
    dangerousRenderedHTML: {
      __html: html || "Nothing to preview"
    },
    loading: html === null,
    openLinksInNewTab: true
  }))), (_slots$footer = slots.footer) !== null && _slots$footer !== void 0 ? _slots$footer : import_react41.default.createElement(CoreFooter, null, import_react41.default.isValidElement(slots.actions) && slots.actions.props.children))));
});

// node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/index.js
var MarkdownEditor2 = Object.assign(MarkdownEditor, {
  /** REQUIRED: An accessible label for the editor. */
  Label,
  /**
   * An optional custom toolbar. The toolbar should contain `ToolbarButton`s before
   * and/or after a `DefaultToolbarButtons` instance. To create groups of buttons, wrap
   * them in an unstyled `Box`.
   */
  Toolbar,
  /**
   * A custom toolbar button. This takes `IconButton` props. Every toolbar button should
   * have an `aria-label` defined.
   */
  ToolbarButton,
  /**
   * The full set of default toolbar buttons. This is all the basic formatting tools in a
   * standardized order.
   */
  DefaultToolbarButtons,
  /** An optional custom footer to show below the editor. */
  Footer,
  /** A button to show in the editor footer before the `DefaultFooterButtons`, i.e.
   * the "Markdown is supported" button and file upload button in a standardized order. */
  FooterButton,
  /**
   * Optionally define a set of custom buttons to show in the footer. Often if you
   * are defining custom buttons you should also wrap the editor in a `<form>`. This
   * component should only contain `ActionButton`s.
   */
  Actions,
  /** A button to show in the editor footer after the `DefaultFooterButtons`, i.e.
   * the "Markdown is supported" button and file upload button in a standardized order. */
  ActionButton
});

// node_modules/@primer/react/lib-esm/Hidden/Hidden.js
var import_react42 = __toESM(require_react());
function normalize(hiddenViewports) {
  if (Array.isArray(hiddenViewports)) {
    const breakpoints = {};
    for (const breakpoint of hiddenViewports) {
      breakpoints[breakpoint] = true;
    }
    return breakpoints;
  }
  return {
    [hiddenViewports]: true
  };
}
var Hidden = ({
  when,
  children
}) => {
  const styles2 = getBreakpointDeclarations(normalize(when), "display", () => "none");
  return styles2 ? import_react42.default.createElement(Box, {
    sx: styles2
  }, children) : null;
};
Hidden.displayName = "Hidden";

// node_modules/@primer/react/lib-esm/drafts/SelectPanel2/SelectPanel.js
var import_react43 = __toESM(require_react());
var import_deepmerge3 = __toESM(require_cjs());
var import_react_dom3 = __toESM(require_react_dom());
function _extends12() {
  return _extends12 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends12.apply(null, arguments);
}
var SelectPanelContext = import_react43.default.createContext({
  title: "",
  description: void 0,
  panelId: "",
  onCancel: () => {
  },
  onClearSelection: void 0,
  searchQuery: "",
  setSearchQuery: () => {
  },
  selectionVariant: "multiple",
  moveFocusToList: () => {
  }
});
var responsiveButtonSizes = {
  narrow: "medium",
  regular: "small"
};
var Panel = ({
  title,
  description,
  variant: propsVariant,
  selectionVariant = "multiple",
  id,
  defaultOpen = false,
  open: propsOpen,
  anchorRef: providedAnchorRef,
  onCancel: propsOnCancel,
  onClearSelection: propsOnClearSelection,
  onSubmit: propsOnSubmit,
  width = "medium",
  maxHeight = "large",
  ...props
}) => {
  var _slots$header;
  const [internalOpen, setInternalOpen] = import_react43.default.useState(defaultOpen);
  const responsiveVariants = Object.assign(
    {
      regular: "anchored",
      narrow: "full-screen"
    },
    // defaults
    typeof propsVariant === "string" ? {
      regular: propsVariant
    } : propsVariant
  );
  const currentVariant = useResponsiveValue(responsiveVariants, "anchored");
  if (propsOpen !== void 0 && internalOpen !== propsOpen) setInternalOpen(propsOpen);
  let Anchor;
  const anchorRef = useProvidedRefOrCreate(providedAnchorRef);
  const onAnchorClick = () => {
    if (!internalOpen) setInternalOpen(true);
    else onInternalCancel();
  };
  const contents = import_react43.default.Children.map(props.children, (child) => {
    if (import_react43.default.isValidElement(child) && child.type === SelectPanelButton) {
      Anchor = import_react43.default.cloneElement(child, {
        // @ts-ignore TODO
        ref: anchorRef,
        onClick: child.props.onClick || onAnchorClick,
        "aria-haspopup": true,
        "aria-expanded": internalOpen
      });
      return null;
    }
    return child;
  });
  const onInternalClose = import_react43.default.useCallback(() => {
    if (internalOpen === false) return;
    if (propsOpen === void 0) setInternalOpen(false);
  }, [internalOpen, propsOpen]);
  const onInternalCancel = import_react43.default.useCallback(() => {
    onInternalClose();
    if (typeof propsOnCancel === "function") propsOnCancel();
  }, [onInternalClose, propsOnCancel]);
  const onInternalSubmit = (event) => {
    event === null || event === void 0 ? void 0 : event.preventDefault();
    onInternalClose();
    if (typeof propsOnSubmit === "function") propsOnSubmit(event);
  };
  const onInternalClearSelection = () => {
    if (typeof propsOnClearSelection === "function") propsOnClearSelection();
  };
  const internalAfterSelect = (event) => {
    if (selectionVariant === "instant") onInternalSubmit();
    if (event.type === "keypress") {
      if (event.key === "Enter") onInternalSubmit();
    }
  };
  const [searchQuery, setSearchQuery] = import_react43.default.useState("");
  const panelId = useId(id);
  const [slots, childrenInBody] = useSlots(contents, {
    header: SelectPanelHeader,
    footer: SelectPanelFooter
  });
  const moveFocusToList = () => {
    var _dialogRef$current;
    const selector = "ul[role=listbox] li:not([role=none])";
    const firstListElement = (_dialogRef$current = dialogRef.current) === null || _dialogRef$current === void 0 ? void 0 : _dialogRef$current.querySelector(selector);
    firstListElement === null || firstListElement === void 0 ? void 0 : firstListElement.focus();
  };
  const dialogRef = import_react43.default.useRef(null);
  import_react43.default.useEffect(() => {
    var _dialogRef$current2, _dialogRef$current3;
    if (internalOpen) (_dialogRef$current2 = dialogRef.current) === null || _dialogRef$current2 === void 0 ? void 0 : _dialogRef$current2.showModal();
    else if ((_dialogRef$current3 = dialogRef.current) !== null && _dialogRef$current3 !== void 0 && _dialogRef$current3.open) dialogRef.current.close();
  }, [internalOpen]);
  import_react43.default.useEffect(() => {
    const dialogEl = dialogRef.current;
    dialogEl === null || dialogEl === void 0 ? void 0 : dialogEl.addEventListener("close", onInternalClose);
    return () => dialogEl === null || dialogEl === void 0 ? void 0 : dialogEl.removeEventListener("close", onInternalClose);
  }, [onInternalClose]);
  import_react43.default.useEffect(() => {
    const dialogEl = dialogRef.current;
    const handler = (event) => {
      if (event.key === "Escape") onInternalCancel();
    };
    dialogEl === null || dialogEl === void 0 ? void 0 : dialogEl.addEventListener("keydown", handler);
    return () => dialogEl === null || dialogEl === void 0 ? void 0 : dialogEl.removeEventListener("keydown", handler);
  }, [onInternalCancel]);
  import_react43.default.useEffect(function intialFocus() {
    if (internalOpen) {
      const searchInput = document.querySelector("dialog[open] input");
      if (searchInput) searchInput.focus();
      else moveFocusToList();
    }
  }, [internalOpen]);
  const {
    position
  } = useAnchoredPosition({
    anchorElementRef: anchorRef,
    floatingElementRef: dialogRef,
    side: "outside-bottom",
    align: "start"
  }, [internalOpen, anchorRef.current, dialogRef.current]);
  const onClickOutside = onInternalCancel;
  return import_react43.default.createElement(import_react43.default.Fragment, null, Anchor, import_react43.default.createElement(StyledOverlay, _extends12({
    as: "dialog",
    ref: dialogRef,
    "aria-labelledby": `${panelId}--title`,
    "aria-describedby": description ? `${panelId}--description` : void 0,
    width,
    height: "fit-content",
    maxHeight,
    "data-variant": currentVariant,
    sx: {
      "--max-height": heightMap[maxHeight],
      // reset dialog default styles
      border: "none",
      padding: 0,
      color: "fg.default",
      "&[open]": {
        display: "flex"
      },
      // to fit children
      '&[data-variant="anchored"], &[data-variant="full-screen"]': {
        margin: 0,
        top: position === null || position === void 0 ? void 0 : position.top,
        left: position === null || position === void 0 ? void 0 : position.left,
        "::backdrop": {
          backgroundColor: "transparent"
        }
      },
      '&[data-variant="modal"]': {
        "::backdrop": {
          backgroundColor: "primer.canvas.backdrop"
        }
      },
      '&[data-variant="full-screen"]': {
        margin: 0,
        top: 0,
        left: 0,
        width: "100%",
        maxWidth: "100vw",
        height: "100%",
        maxHeight: "100vh",
        "--max-height": "100vh",
        borderRadius: "unset"
      },
      '&[data-variant="bottom-sheet"]': {
        margin: 0,
        top: "auto",
        bottom: 0,
        left: 0,
        width: "100%",
        maxWidth: "100vw",
        maxHeight: "calc(100vh - 64px)",
        "--max-height": "calc(100vh - 64px)",
        borderBottomRightRadius: 0,
        borderBottomLeftRadius: 0
      }
    }
  }, props, {
    onClick: (event) => {
      if (event.target === event.currentTarget) onClickOutside();
    }
  }), internalOpen && import_react43.default.createElement(import_react43.default.Fragment, null, import_react43.default.createElement(SelectPanelContext.Provider, {
    value: {
      panelId,
      title,
      description,
      onCancel: onInternalCancel,
      onClearSelection: propsOnClearSelection ? onInternalClearSelection : void 0,
      searchQuery,
      setSearchQuery,
      selectionVariant,
      moveFocusToList
    }
  }, import_react43.default.createElement(Box, {
    as: "form",
    method: "dialog",
    onSubmit: onInternalSubmit,
    sx: {
      display: "flex",
      flexDirection: "column",
      width: "100%"
    }
  }, (_slots$header = slots.header) !== null && _slots$header !== void 0 ? _slots$header : (
    /* render default header as fallback */
    import_react43.default.createElement(SelectPanelHeader, null)
  ), import_react43.default.createElement(Box, {
    as: "div",
    sx: {
      flexShrink: 1,
      flexGrow: 1,
      overflow: "hidden",
      display: "flex",
      flexDirection: "column",
      justifyContent: "space-between",
      ul: {
        overflowY: "auto",
        flexGrow: 1
      }
    }
  }, import_react43.default.createElement(ActionListContainerContext.Provider, {
    value: {
      container: "SelectPanel",
      listRole: "listbox",
      selectionAttribute: "aria-selected",
      selectionVariant: selectionVariant === "instant" ? "single" : selectionVariant,
      afterSelect: internalAfterSelect,
      listLabelledBy: `${panelId}--title`,
      enableFocusZone: true
      // Arrow keys navigation for list items
    }
  }, childrenInBody)), slots.footer)))));
};
var SelectPanelButton = import_react43.default.forwardRef((props, anchorRef) => {
  const inputProps = useFormControlForwardedProps(props);
  const [labelText, setLabelText] = (0, import_react43.useState)("");
  (0, import_react43.useEffect)(() => {
    const label = document.querySelector(`[for='${inputProps.id}']`);
    if (label !== null && label !== void 0 && label.textContent) {
      setLabelText(label.textContent);
    }
  }, [inputProps.id]);
  if (labelText) {
    return import_react43.default.createElement(ButtonComponent, _extends12({
      ref: anchorRef,
      "aria-label": `${anchorRef.current.textContent}, ${labelText}`
    }, inputProps));
  } else {
    return import_react43.default.createElement(ButtonComponent, _extends12({
      ref: anchorRef
    }, props));
  }
});
var SelectPanelHeader = ({
  children,
  onBack,
  ...props
}) => {
  const [slots, childrenWithoutSlots] = useSlots(children, {
    searchInput: SelectPanelSearchInput
  });
  const {
    title,
    description,
    panelId,
    onCancel,
    onClearSelection
  } = import_react43.default.useContext(SelectPanelContext);
  return import_react43.default.createElement(Box, _extends12({
    sx: {
      display: "flex",
      flexDirection: "column",
      // gap: 2,
      padding: 2,
      borderBottom: "1px solid",
      borderColor: "border.default"
    }
  }, props), import_react43.default.createElement(Box, {
    sx: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: description ? "start" : "center",
      marginBottom: slots.searchInput ? 2 : 0
    }
  }, import_react43.default.createElement(Box, {
    sx: {
      display: "flex"
    }
  }, onBack ? import_react43.default.createElement(IconButton, {
    type: "button",
    variant: "invisible",
    icon: ArrowLeftIcon,
    "aria-label": "Back",
    onClick: () => onBack()
  }) : null, import_react43.default.createElement(Box, {
    sx: {
      marginLeft: onBack ? 1 : 2,
      marginTop: description ? "2px" : 0
    }
  }, import_react43.default.createElement(Heading, {
    as: "h1",
    id: `${panelId}--title`,
    sx: {
      fontSize: 14,
      fontWeight: 600
    }
  }, title), description ? import_react43.default.createElement(Text, {
    id: `${panelId}--description`,
    sx: {
      fontSize: 0,
      color: "fg.muted",
      display: "block"
    }
  }, description) : null)), import_react43.default.createElement(Box, null, onClearSelection ? import_react43.default.createElement(IconButton, {
    type: "button",
    variant: "invisible",
    icon: FilterRemoveIcon,
    "aria-label": "Clear selection",
    onClick: onClearSelection
  }) : null, import_react43.default.createElement(IconButton, {
    type: "button",
    variant: "invisible",
    icon: XIcon,
    "aria-label": "Close",
    onClick: () => onCancel()
  }))), slots.searchInput, childrenWithoutSlots);
};
SelectPanelHeader.displayName = "SelectPanelHeader";
var SelectPanelSearchInput = ({
  onChange: propsOnChange,
  onKeyDown: propsOnKeyDown,
  ...props
}) => {
  const inputRef = import_react43.default.createRef();
  const {
    setSearchQuery,
    moveFocusToList
  } = import_react43.default.useContext(SelectPanelContext);
  const internalOnChange = (event) => {
    if (typeof propsOnChange === "function") propsOnChange(event);
    else setSearchQuery(event.target.value);
  };
  const internalKeyDown = (event) => {
    if (event.key === "ArrowDown") {
      event.preventDefault();
      moveFocusToList();
    }
    if (typeof propsOnKeyDown === "function") propsOnKeyDown(event);
  };
  return import_react43.default.createElement(TextInput$1, _extends12({
    ref: inputRef,
    block: true,
    leadingVisual: SearchIcon,
    placeholder: "Search",
    trailingAction: import_react43.default.createElement(TextInput$1.Action, {
      icon: XCircleFillIcon,
      "aria-label": "Clear",
      tooltipDirection: "w",
      sx: {
        color: "fg.subtle",
        bg: "none"
      },
      onClick: () => {
        if (inputRef.current) inputRef.current.value = "";
        if (typeof propsOnChange === "function") {
          propsOnChange({
            target: inputRef.current,
            currentTarget: inputRef.current
          });
        }
      }
    }),
    sx: {
      paddingLeft: 2,
      // align with list checkboxes
      "&:has(input:placeholder-shown) .TextInput-action": {
        display: "none"
      }
    },
    onChange: internalOnChange,
    onKeyDown: internalKeyDown
  }, props));
};
SelectPanelSearchInput.displayName = "SelectPanelSearchInput";
var FooterContext = import_react43.default.createContext(false);
var SelectPanelFooter = ({
  ...props
}) => {
  const {
    onCancel,
    selectionVariant
  } = import_react43.default.useContext(SelectPanelContext);
  const hidePrimaryActions = selectionVariant === "instant";
  const buttonSize = useResponsiveValue(responsiveButtonSizes, "small");
  if (hidePrimaryActions && !props.children) {
    return null;
  }
  return import_react43.default.createElement(FooterContext.Provider, {
    value: true
  }, import_react43.default.createElement(Box, {
    sx: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      flexShrink: 0,
      padding: hidePrimaryActions ? 2 : 3,
      minHeight: "44px",
      borderTop: "1px solid",
      borderColor: "border.default"
    }
  }, import_react43.default.createElement(Box, {
    sx: {
      flexGrow: hidePrimaryActions ? 1 : 0
    }
  }, props.children), hidePrimaryActions ? null : import_react43.default.createElement(Box, {
    sx: {
      display: "flex",
      gap: 2
    }
  }, import_react43.default.createElement(ButtonComponent, {
    type: "button",
    size: buttonSize,
    onClick: () => onCancel()
  }, "Cancel"), import_react43.default.createElement(ButtonComponent, {
    type: "submit",
    size: buttonSize,
    variant: "primary"
  }, "Save"))));
};
SelectPanelFooter.displayName = "SelectPanelFooter";
var SecondaryButton = (props) => {
  const size = useResponsiveValue(responsiveButtonSizes, "small");
  return import_react43.default.createElement(ButtonComponent, _extends12({
    type: "button",
    size,
    block: true
  }, props));
};
SecondaryButton.displayName = "SecondaryButton";
var SecondaryLink = (props) => {
  const size = useResponsiveValue(responsiveButtonSizes, "small");
  return (
    // @ts-ignore TODO: is as prop is not recognised by button?
    import_react43.default.createElement(ButtonComponent, _extends12({
      as: Link,
      size,
      variant: "invisible",
      block: true
    }, props, {
      sx: {
        fontSize: 0
      }
    }), props.children)
  );
};
SecondaryLink.displayName = "SecondaryLink";
var SecondaryCheckbox = ({
  id,
  children,
  ...props
}) => {
  const checkboxId = useId(id);
  const {
    selectionVariant
  } = import_react43.default.useContext(SelectPanelContext);
  !(selectionVariant !== "instant") ? true ? invariant(false, 'Sorry! SelectPanel.SecondaryAction with variant="checkbox" is not allowed inside selectionVariant="instant"') : invariant(false) : void 0;
  return import_react43.default.createElement(Box, {
    sx: {
      display: "flex",
      alignItems: "center",
      gap: 2
    }
  }, import_react43.default.createElement(Checkbox, _extends12({
    id: checkboxId,
    sx: {
      marginTop: 0
    }
  }, props)), import_react43.default.createElement(InputLabel, {
    htmlFor: checkboxId,
    sx: {
      fontSize: 0
    }
  }, children));
};
SecondaryCheckbox.displayName = "SecondaryCheckbox";
var SelectPanelSecondaryAction = ({
  variant,
  ...props
}) => {
  const insideFooter = import_react43.default.useContext(FooterContext);
  !insideFooter ? true ? invariant(false, "SelectPanel.SecondaryAction is only allowed inside SelectPanel.Footer") : invariant(false) : void 0;
  if (variant === "button") return import_react43.default.createElement(SecondaryButton, props);
  else if (variant === "link") return import_react43.default.createElement(SecondaryLink, props);
  else if (variant === "checkbox") return import_react43.default.createElement(SecondaryCheckbox, props);
};
var SelectPanelLoading = ({
  children = "Fetching items..."
}) => {
  return import_react43.default.createElement(AriaStatus, {
    announceOnShow: true,
    sx: {
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      height: "100%",
      gap: 3,
      minHeight: "min(calc(var(--max-height) - 150px), 324px)"
      //                 maxHeight of dialog - (header & footer)
    }
  }, import_react43.default.createElement(StyledSpinner, {
    size: "medium",
    srText: null
  }), import_react43.default.createElement(Text, {
    sx: {
      fontSize: 1,
      color: "fg.muted"
    }
  }, children));
};
SelectPanelLoading.displayName = "SelectPanelLoading";
var SelectPanelMessage = ({
  variant = "warning",
  size = variant === "empty" ? "full" : "inline",
  title,
  children
}) => {
  if (size === "full") {
    return import_react43.default.createElement(Box, {
      "aria-live": variant === "empty" ? void 0 : "polite",
      sx: {
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        flexGrow: 1,
        height: "100%",
        gap: 1,
        paddingX: 4,
        textAlign: "center",
        a: {
          color: "inherit",
          textDecoration: "underline"
        },
        minHeight: "min(calc(var(--max-height) - 150px), 324px)"
        //                 maxHeight of dialog - (header & footer)
      }
    }, variant !== "empty" ? import_react43.default.createElement(Octicon, {
      icon: AlertIcon,
      sx: {
        color: variant === "error" ? "danger.fg" : "attention.fg",
        marginBottom: 2
      }
    }) : null, import_react43.default.createElement(Text, {
      sx: {
        fontSize: 1,
        fontWeight: "semibold"
      }
    }, title), import_react43.default.createElement(Text, {
      sx: {
        fontSize: 1,
        color: "fg.muted",
        display: "flex",
        flexDirection: "column",
        gap: 2,
        alignItems: "center"
      }
    }, children));
  } else {
    const inlineVariantStyles = {
      empty: {},
      warning: {
        backgroundColor: "attention.subtle",
        color: "attention.fg",
        borderBottomColor: "attention.muted"
      },
      error: {
        backgroundColor: "danger.subtle",
        color: "danger.fg",
        borderColor: "danger.muted"
      }
    };
    return import_react43.default.createElement(Box, {
      "aria-live": variant === "empty" ? void 0 : "polite",
      sx: {
        display: "flex",
        gap: 2,
        paddingX: 3,
        paddingY: "12px",
        fontSize: 0,
        borderBottom: "1px solid",
        a: {
          color: "inherit",
          textDecoration: "underline"
        },
        ...inlineVariantStyles[variant]
      }
    }, import_react43.default.createElement(AlertIcon, {
      size: 16
    }), import_react43.default.createElement(Box, null, children));
  }
};
var SelectPanel2 = Object.assign(Panel, {
  Button: SelectPanelButton,
  Header: SelectPanelHeader,
  SearchInput: SelectPanelSearchInput,
  Footer: SelectPanelFooter,
  Loading: SelectPanelLoading,
  Message: SelectPanelMessage,
  SecondaryAction: SelectPanelSecondaryAction
});

// node_modules/@primer/react/lib-esm/drafts/TabPanels/TabPanels.js
var import_react45 = __toESM(require_react());

// node_modules/@github/tab-container-element/dist/tab-container-element.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _a;
var _TabContainerChangeEvent_tabIndex;
var _TabContainerChangeEvent_panel;
var _TabContainerChangeEvent_tab;
var _TabContainerElement_instances;
var _TabContainerElement_onTabContainerChange;
var _TabContainerElement_onTabContainerChanged;
var _TabContainerElement_tabList_get;
var _TabContainerElement_tabListWrapper_get;
var _TabContainerElement_tabListTabWrapper_get;
var _TabContainerElement_beforeTabsSlot_get;
var _TabContainerElement_afterTabsSlot_get;
var _TabContainerElement_afterPanelsSlot_get;
var _TabContainerElement_tabListSlot_get;
var _TabContainerElement_panelSlot_get;
var _TabContainerElement_tabs_get;
var _TabContainerElement_setupComplete;
var _TabContainerElement_internals;
var _TabContainerElement_handleKeydown;
var _TabContainerElement_handleClick;
var _TabContainerElement_reflectAttributeToShadow;
var HTMLElement2 = globalThis.HTMLElement || null;
var assignSlotWithFallback = "assign" in (((_a = globalThis.HTMLSlotElement) === null || _a === void 0 ? void 0 : _a.prototype) || {}) ? (slot, ...elements) => {
  slot.assign(...elements);
} : (slot, ...elements) => {
  const host = slot.getRootNode().host;
  for (const element of host.querySelectorAll(`[slot="${slot.name}"]`)) {
    element.removeAttribute("slot");
  }
  for (const element of elements) {
    element.setAttribute("slot", slot.name);
  }
};
var TabContainerChangeEvent = class extends Event {
  constructor(type, _a2) {
    var { tabIndex, tab, panel } = _a2, init = __rest(_a2, ["tabIndex", "tab", "panel"]);
    super(type, init);
    _TabContainerChangeEvent_tabIndex.set(this, null);
    _TabContainerChangeEvent_panel.set(this, null);
    _TabContainerChangeEvent_tab.set(this, null);
    __classPrivateFieldSet(this, _TabContainerChangeEvent_tab, tab || null, "f");
    __classPrivateFieldSet(this, _TabContainerChangeEvent_tabIndex, tabIndex || null, "f");
    __classPrivateFieldSet(this, _TabContainerChangeEvent_panel, panel || null, "f");
  }
  get detail() {
    console.warn("TabContainerElement.detail is deprecated, please use .panel instead");
    return { relatedTarget: __classPrivateFieldGet2(this, _TabContainerChangeEvent_panel, "f") };
  }
  get tabIndex() {
    return __classPrivateFieldGet2(this, _TabContainerChangeEvent_tabIndex, "f");
  }
  get panel() {
    return __classPrivateFieldGet2(this, _TabContainerChangeEvent_panel, "f");
  }
  get tab() {
    return __classPrivateFieldGet2(this, _TabContainerChangeEvent_tab, "f");
  }
};
_TabContainerChangeEvent_tabIndex = /* @__PURE__ */ new WeakMap(), _TabContainerChangeEvent_panel = /* @__PURE__ */ new WeakMap(), _TabContainerChangeEvent_tab = /* @__PURE__ */ new WeakMap();
var TabContainerElement = class extends HTMLElement2 {
  constructor() {
    super(...arguments);
    _TabContainerElement_instances.add(this);
    _TabContainerElement_onTabContainerChange.set(this, null);
    _TabContainerElement_onTabContainerChanged.set(this, null);
    _TabContainerElement_setupComplete.set(this, false);
    _TabContainerElement_internals.set(this, void 0);
  }
  static define(tag = "tab-container", registry = customElements) {
    registry.define(tag, this);
    return this;
  }
  get onChange() {
    return this.onTabContainerChange;
  }
  set onChange(listener) {
    this.onTabContainerChange = listener;
  }
  get onTabContainerChange() {
    return __classPrivateFieldGet2(this, _TabContainerElement_onTabContainerChange, "f");
  }
  set onTabContainerChange(listener) {
    if (__classPrivateFieldGet2(this, _TabContainerElement_onTabContainerChange, "f")) {
      this.removeEventListener("tab-container-change", __classPrivateFieldGet2(this, _TabContainerElement_onTabContainerChange, "f"));
    }
    __classPrivateFieldSet(this, _TabContainerElement_onTabContainerChange, typeof listener === "object" || typeof listener === "function" ? listener : null, "f");
    if (typeof listener === "function") {
      this.addEventListener("tab-container-change", listener);
    }
  }
  get onTabContainerChanged() {
    return __classPrivateFieldGet2(this, _TabContainerElement_onTabContainerChanged, "f");
  }
  set onTabContainerChanged(listener) {
    if (__classPrivateFieldGet2(this, _TabContainerElement_onTabContainerChanged, "f")) {
      this.removeEventListener("tab-container-changed", __classPrivateFieldGet2(this, _TabContainerElement_onTabContainerChanged, "f"));
    }
    __classPrivateFieldSet(this, _TabContainerElement_onTabContainerChanged, typeof listener === "object" || typeof listener === "function" ? listener : null, "f");
    if (typeof listener === "function") {
      this.addEventListener("tab-container-changed", listener);
    }
  }
  get onChanged() {
    return this.onTabContainerChanged;
  }
  set onChanged(listener) {
    this.onTabContainerChanged = listener;
  }
  get activeTab() {
    return __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabs_get)[this.selectedTabIndex];
  }
  get activePanel() {
    return __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_panelSlot_get).assignedNodes()[0];
  }
  get vertical() {
    var _a2;
    return ((_a2 = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabList_get)) === null || _a2 === void 0 ? void 0 : _a2.getAttribute("aria-orientation")) === "vertical";
  }
  set vertical(isVertical) {
    const tabList = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabList_get);
    if (tabList && isVertical) {
      tabList.setAttribute("aria-orientation", "vertical");
    } else {
      tabList.setAttribute("aria-orientation", "horizontal");
    }
  }
  connectedCallback() {
    __classPrivateFieldSet(this, _TabContainerElement_internals, __classPrivateFieldGet2(this, _TabContainerElement_internals, "f") || (this.attachInternals ? this.attachInternals() : null), "f");
    const shadowRoot = this.shadowRoot || this.attachShadow({ mode: "open", slotAssignment: "manual" });
    const tabListContainer = document.createElement("slot");
    tabListContainer.style.display = "flex";
    tabListContainer.setAttribute("part", "tablist-wrapper");
    tabListContainer.setAttribute("name", "tablist-wrapper");
    const tabListTabWrapper = document.createElement("div");
    tabListTabWrapper.setAttribute("part", "tablist-tab-wrapper");
    tabListTabWrapper.setAttribute("name", "tablist-tab-wrapper");
    const tabListSlot = document.createElement("slot");
    tabListSlot.setAttribute("part", "tablist");
    tabListSlot.setAttribute("name", "tablist");
    tabListTabWrapper.append(tabListSlot);
    const panelSlot = document.createElement("slot");
    panelSlot.setAttribute("part", "panel");
    panelSlot.setAttribute("name", "panel");
    const beforeTabSlot = document.createElement("slot");
    beforeTabSlot.setAttribute("part", "before-tabs");
    beforeTabSlot.setAttribute("name", "before-tabs");
    const afterTabSlot = document.createElement("slot");
    afterTabSlot.setAttribute("part", "after-tabs");
    afterTabSlot.setAttribute("name", "after-tabs");
    tabListContainer.append(beforeTabSlot, tabListTabWrapper, afterTabSlot);
    const afterSlot = document.createElement("slot");
    afterSlot.setAttribute("part", "after-panels");
    afterSlot.setAttribute("name", "after-panels");
    shadowRoot.replaceChildren(tabListContainer, panelSlot, afterSlot);
    if (__classPrivateFieldGet2(this, _TabContainerElement_internals, "f") && "role" in __classPrivateFieldGet2(this, _TabContainerElement_internals, "f")) {
      __classPrivateFieldGet2(this, _TabContainerElement_internals, "f").role = "presentation";
    } else {
      this.setAttribute("role", "presentation");
    }
    this.addEventListener("keydown", this);
    this.addEventListener("click", this);
    this.selectTab(-1);
    if (!__classPrivateFieldGet2(this, _TabContainerElement_setupComplete, "f")) {
      const mutationObserver = new MutationObserver(() => {
        this.selectTab(-1);
        if (__classPrivateFieldGet2(this, _TabContainerElement_setupComplete, "f")) {
          mutationObserver.disconnect();
        }
      });
      mutationObserver.observe(this, { childList: true, subtree: true });
    }
  }
  attributeChangedCallback(name) {
    if (!this.isConnected || !this.shadowRoot)
      return;
    if (name === "vertical") {
      this.vertical = this.hasAttribute("vertical");
    }
  }
  handleEvent(event) {
    if (event.type === "click")
      return __classPrivateFieldGet2(this, _TabContainerElement_instances, "m", _TabContainerElement_handleClick).call(this, event);
    if (event.type === "keydown")
      return __classPrivateFieldGet2(this, _TabContainerElement_instances, "m", _TabContainerElement_handleKeydown).call(this, event);
  }
  get selectedTabIndex() {
    return __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabs_get).findIndex((el) => el.matches("[aria-selected=true]"));
  }
  set selectedTabIndex(i) {
    this.selectTab(i);
  }
  get defaultTabIndex() {
    return Number(this.getAttribute("default-tab") || -1);
  }
  set defaultTabIndex(index) {
    this.setAttribute("default-tab", String(index));
  }
  selectTab(index) {
    var _a2;
    if (!__classPrivateFieldGet2(this, _TabContainerElement_setupComplete, "f")) {
      const tabListSlot = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListSlot_get);
      const tabListWrapper = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListWrapper_get);
      const customTabList = this.querySelector("[role=tablist]");
      const customTabListWrapper = this.querySelector("[slot=tablist-wrapper]");
      if (customTabListWrapper && customTabListWrapper.closest(this.tagName) === this) {
        assignSlotWithFallback(tabListWrapper, customTabListWrapper);
      } else if (customTabList && customTabList.closest(this.tagName) === this) {
        assignSlotWithFallback(tabListSlot, customTabList);
      } else {
        __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListTabWrapper_get).role = "tablist";
        assignSlotWithFallback(tabListSlot, ...[...this.children].filter((e) => e.matches("[role=tab]")));
      }
      const tabList = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabList_get);
      __classPrivateFieldGet2(this, _TabContainerElement_instances, "m", _TabContainerElement_reflectAttributeToShadow).call(this, "aria-description", tabList);
      __classPrivateFieldGet2(this, _TabContainerElement_instances, "m", _TabContainerElement_reflectAttributeToShadow).call(this, "aria-label", tabList);
      if (this.vertical) {
        __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabList_get).setAttribute("aria-orientation", "vertical");
      }
      const bringsOwnWrapper = ((_a2 = this.querySelector("[slot=tablist-wrapper]")) === null || _a2 === void 0 ? void 0 : _a2.closest(this.tagName)) === this;
      if (!bringsOwnWrapper) {
        const beforeSlotted = [];
        const afterTabSlotted = [];
        const afterSlotted = [];
        let autoSlotted = beforeSlotted;
        for (const child of this.children) {
          if (child.getAttribute("role") === "tab" || child.getAttribute("role") === "tablist") {
            autoSlotted = afterTabSlotted;
            continue;
          }
          if (child.getAttribute("role") === "tabpanel") {
            autoSlotted = afterSlotted;
            continue;
          }
          if (child.getAttribute("slot") === "before-tabs") {
            beforeSlotted.push(child);
          } else if (child.getAttribute("slot") === "after-tabs") {
            afterTabSlotted.push(child);
          } else {
            autoSlotted.push(child);
          }
        }
        assignSlotWithFallback(__classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_beforeTabsSlot_get), ...beforeSlotted);
        assignSlotWithFallback(__classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_afterTabsSlot_get), ...afterTabSlotted);
        assignSlotWithFallback(__classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_afterPanelsSlot_get), ...afterSlotted);
      }
      const defaultTab = this.defaultTabIndex;
      const defaultIndex = defaultTab >= 0 ? defaultTab : this.selectedTabIndex;
      index = index >= 0 ? index : Math.max(0, defaultIndex);
    }
    const tabs = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabs_get);
    const panels = Array.from(this.querySelectorAll('[role="tabpanel"]')).filter((panel) => panel.closest(this.tagName) === this);
    if (index > tabs.length - 1) {
      return;
    }
    const selectedTab = tabs[index];
    const selectedPanel = panels[index];
    if (!selectedTab)
      return;
    if (!selectedPanel)
      return;
    if (__classPrivateFieldGet2(this, _TabContainerElement_setupComplete, "f")) {
      const cancelled = !this.dispatchEvent(new TabContainerChangeEvent("tab-container-change", {
        tabIndex: index,
        bubbles: true,
        cancelable: true,
        tab: selectedTab,
        panel: selectedPanel
      }));
      if (cancelled)
        return;
    }
    for (const tab of tabs) {
      tab.setAttribute("aria-selected", "false");
      tab.setAttribute("tabindex", "-1");
    }
    for (const panel of panels) {
      if (!panel.hasAttribute("tabindex") && !panel.hasAttribute("data-tab-container-no-tabstop")) {
        panel.setAttribute("tabindex", "0");
      }
    }
    selectedTab.setAttribute("aria-selected", "true");
    selectedTab.setAttribute("tabindex", "0");
    assignSlotWithFallback(__classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_panelSlot_get), selectedPanel);
    selectedPanel.hidden = false;
    if (__classPrivateFieldGet2(this, _TabContainerElement_setupComplete, "f")) {
      selectedTab.focus();
      this.dispatchEvent(new TabContainerChangeEvent("tab-container-changed", {
        tabIndex: index,
        bubbles: true,
        tab: selectedTab,
        panel: selectedPanel
      }));
    }
    __classPrivateFieldSet(this, _TabContainerElement_setupComplete, true, "f");
  }
};
_TabContainerElement_onTabContainerChange = /* @__PURE__ */ new WeakMap(), _TabContainerElement_onTabContainerChanged = /* @__PURE__ */ new WeakMap(), _TabContainerElement_setupComplete = /* @__PURE__ */ new WeakMap(), _TabContainerElement_internals = /* @__PURE__ */ new WeakMap(), _TabContainerElement_instances = /* @__PURE__ */ new WeakSet(), _TabContainerElement_tabList_get = function _TabContainerElement_tabList_get2() {
  const wrapper = this.querySelector("[slot=tablist-wrapper]");
  if ((wrapper === null || wrapper === void 0 ? void 0 : wrapper.closest(this.tagName)) === this) {
    return wrapper.querySelector("[role=tablist]");
  }
  const slot = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListSlot_get);
  if (__classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListTabWrapper_get).hasAttribute("role")) {
    return __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListTabWrapper_get);
  } else {
    return slot.assignedNodes()[0];
  }
}, _TabContainerElement_tabListWrapper_get = function _TabContainerElement_tabListWrapper_get2() {
  return this.shadowRoot.querySelector('slot[part="tablist-wrapper"]');
}, _TabContainerElement_tabListTabWrapper_get = function _TabContainerElement_tabListTabWrapper_get2() {
  return this.shadowRoot.querySelector('div[part="tablist-tab-wrapper"]');
}, _TabContainerElement_beforeTabsSlot_get = function _TabContainerElement_beforeTabsSlot_get2() {
  return this.shadowRoot.querySelector('slot[part="before-tabs"]');
}, _TabContainerElement_afterTabsSlot_get = function _TabContainerElement_afterTabsSlot_get2() {
  return this.shadowRoot.querySelector('slot[part="after-tabs"]');
}, _TabContainerElement_afterPanelsSlot_get = function _TabContainerElement_afterPanelsSlot_get2() {
  return this.shadowRoot.querySelector('slot[part="after-panels"]');
}, _TabContainerElement_tabListSlot_get = function _TabContainerElement_tabListSlot_get2() {
  return this.shadowRoot.querySelector('slot[part="tablist"]');
}, _TabContainerElement_panelSlot_get = function _TabContainerElement_panelSlot_get2() {
  return this.shadowRoot.querySelector('slot[part="panel"]');
}, _TabContainerElement_tabs_get = function _TabContainerElement_tabs_get2() {
  var _a2;
  if (__classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListTabWrapper_get).matches("[role=tablist]")) {
    return __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabListSlot_get).assignedNodes();
  }
  return Array.from(((_a2 = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabList_get)) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll('[role="tab"]')) || []).filter((tab) => tab instanceof HTMLElement2 && tab.closest(this.tagName) === this);
}, _TabContainerElement_handleKeydown = function _TabContainerElement_handleKeydown2(event) {
  var _a2, _b, _c;
  const tab = (_b = (_a2 = event.target) === null || _a2 === void 0 ? void 0 : _a2.closest) === null || _b === void 0 ? void 0 : _b.call(_a2, '[role="tab"]');
  if (!tab)
    return;
  const tabs = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabs_get);
  if (!tabs.includes(tab))
    return;
  const currentIndex = this.selectedTabIndex;
  const vertical = ((_c = tab.closest('[role="tablist"]')) === null || _c === void 0 ? void 0 : _c.getAttribute("aria-orientation")) === "vertical";
  const prevTab = event.code === "ArrowLeft" || vertical && event.code === "ArrowUp";
  const nextTab = event.code === "ArrowRight" || vertical && event.code === "ArrowDown";
  if (nextTab) {
    let index = currentIndex + 1;
    if (index >= tabs.length)
      index = 0;
    this.selectTab(index);
  } else if (prevTab) {
    let index = currentIndex - 1;
    if (index < 0)
      index = tabs.length - 1;
    this.selectTab(index);
  } else if (event.code === "Home") {
    this.selectTab(0);
    event.preventDefault();
  } else if (event.code === "End") {
    this.selectTab(tabs.length - 1);
    event.preventDefault();
  }
}, _TabContainerElement_handleClick = function _TabContainerElement_handleClick2(event) {
  var _a2, _b;
  const tab = (_b = (_a2 = event.target) === null || _a2 === void 0 ? void 0 : _a2.closest) === null || _b === void 0 ? void 0 : _b.call(_a2, "[role=tab]");
  if (!tab)
    return;
  const tabs = __classPrivateFieldGet2(this, _TabContainerElement_instances, "a", _TabContainerElement_tabs_get);
  const index = tabs.indexOf(tab);
  if (index >= 0)
    this.selectTab(index);
}, _TabContainerElement_reflectAttributeToShadow = function _TabContainerElement_reflectAttributeToShadow2(name, node) {
  if (this.hasAttribute(name)) {
    node.setAttribute(name, this.getAttribute(name));
    this.removeAttribute(name);
  }
};
TabContainerElement.observedAttributes = ["vertical"];

// node_modules/@github/tab-container-element/dist/tab-container-element-define.js
var root = typeof globalThis !== "undefined" ? globalThis : window;
try {
  root.TabContainerElement = TabContainerElement.define();
} catch (e) {
  if (!(root.DOMException && e instanceof DOMException && e.name === "NotSupportedError") && !(e instanceof ReferenceError)) {
    throw e;
  }
}

// node_modules/@primer/react/lib-esm/drafts/TabPanels/TabPanels.js
function _extends13() {
  return _extends13 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends13.apply(null, arguments);
}
var TAB_CLASS = "TabPanel-tab";
var tabContainerComponent = createComponent(TabContainerElement, "tab-container");
var TabContainer = styled_components_browser_esm_default(tabContainerComponent).withConfig({
  displayName: "TabPanels__TabContainer",
  componentId: "sc-vjfsxc-0"
})(["& > :not([role='tabpanel']){display:inline-block;}&::part(tablist-wrapper){margin-top:0;margin-bottom:16px;border-bottom:1px solid ", ";}&:not(:defined) [role='tabpanel']{margin-top:17px;display:none;}&:not(:defined) [role='tab']:nth-of-type(1)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(1),&:not(:defined) [role='tab']:nth-of-type(2)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(2),&:not(:defined) [role='tab']:nth-of-type(3)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(3),&:not(:defined) [role='tab']:nth-of-type(4)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(4),&:not(:defined) [role='tab']:nth-of-type(5)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(5),&:not(:defined) [role='tab']:nth-of-type(6)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(6),&:not(:defined) [role='tab']:nth-of-type(7)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(7),&:not(:defined) [role='tab']:nth-of-type(8)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(8),&:not(:defined) [role='tab']:nth-of-type(9)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(9),&:not(:defined) [role='tab']:nth-of-type(10)[aria-selected='true'] ~ [role='tabpanel']:nth-of-type(10){display:block;}&:not(:defined):not(:has([aria-selected='true'])) [role='tabpanel']:first-of-type{display:block;}&:not(:has([aria-selected='true'])) [role='tab'] ~ [role='tab']{color:", ";background-color:transparent;border:1px solid transparent;}&:not(:has([aria-selected='true'])) [role='tab'],& [role='tab'][aria-selected='true']{color:", ";border-color:", ";border-top-right-radius:", ";border-top-left-radius:", ";background-color:", ";}&:not(:defined):not(:has([aria-selected='true'])) [role='tab'] ~ [role='tab'],&:not(:defined):has([aria-selected='true']) [role='tab']:not([aria-selected='true']){padding:8px 16px;border-bottom:1px solid ", ";}&:not(:defined) :not([role='tabpanel']){vertical-align:top;}", ";"], get("colors.border.default"), get("colors.fg.muted"), get("colors.fg.default"), get("colors.border.default"), get("radii.2"), get("radii.2"), get("colors.canvas.default"), get("colors.border.default"), sx);
function TabPanels({
  children,
  defaultTabIndex,
  ...props
}) {
  var _props$id;
  const defaultId = import_react45.default.useId();
  const parentId = (_props$id = props.id) !== null && _props$id !== void 0 ? _props$id : defaultId;
  if (defaultTabIndex !== void 0) {
    props["default-tab"] = defaultTabIndex;
  }
  let tabIndex = 0;
  let panelIndex = 0;
  const childrenWithProps = import_react45.default.Children.map(children, (child) => {
    if (import_react45.default.isValidElement(child) && child.type === Tab) {
      if (props.selectedTabIndex === tabIndex) {
        return import_react45.default.cloneElement(child, {
          id: `${parentId}-tab-${tabIndex++}`,
          selected: true
        });
      }
      return import_react45.default.cloneElement(child, {
        id: `${parentId}-tab-${tabIndex++}`
      });
    }
    if (import_react45.default.isValidElement(child) && child.type === Panel2) {
      return import_react45.default.cloneElement(child, {
        "aria-labelledby": `${parentId}-tab-${panelIndex++}`
      });
    }
    return child;
  });
  return import_react45.default.createElement(TabContainer, _extends13({}, props, {
    id: parentId
  }), childrenWithProps);
}
TabPanels.displayName = "TabPanels";
var Tab = styled_components_browser_esm_default.button.attrs((props) => ({
  className: clsx_m_default(TAB_CLASS, props.className),
  role: "tab",
  "aria-selected": !!props.selected,
  suppressHydrationWarning: true
})).withConfig({
  displayName: "TabPanels__Tab",
  componentId: "sc-vjfsxc-1"
})(["padding:8px 16px 9px 16px;font-size:", ";line-height:23px;color:", ";text-decoration:none;background-color:transparent;border:1px solid transparent;border-bottom:0;margin-bottom:-1px;cursor:pointer;", ";&:hover,&:focus{color:", ";text-decoration:none;}&:hover{transition-duration:0.1s;transition-property:color;}", ";"], get("fontSizes.1"), get("colors.fg.muted"), getGlobalFocusStyles("-6px"), get("colors.fg.default"), sx);
Tab.displayName = "TabPanels.Tab";
var Panel2 = styled_components_browser_esm_default.div.attrs(() => ({
  role: "tabpanel",
  suppressHydrationWarning: true
})).withConfig({
  displayName: "TabPanels__Panel",
  componentId: "sc-vjfsxc-2"
})(["", ";"], sx);
Panel2.displayName = "TabPanels.Panel";
var TabPanels$1 = Object.assign(TabPanels, {
  Panel: Panel2,
  Tab
});

// node_modules/@primer/react/lib-esm/drafts/UnderlinePanels/UnderlinePanels.js
var import_react46 = __toESM(require_react());
var import_deepmerge4 = __toESM(require_cjs());
function _extends14() {
  return _extends14 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends14.apply(null, arguments);
}
var TabContainerComponent = createComponent(TabContainerElement, "tab-container");
var UnderlinePanels = ({
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledBy,
  children,
  loadingCounters,
  sx: sxProp = defaultSxProp,
  ...props
}) => {
  const [iconsVisible, setIconsVisible] = (0, import_react46.useState)(true);
  const wrapperRef = (0, import_react46.useRef)(null);
  const listRef = (0, import_react46.useRef)(null);
  const parentId = useId(props.id);
  let tabIndex = 0;
  let panelIndex = 0;
  const childrenWithProps = import_react46.Children.map(children, (child) => {
    if ((0, import_react46.isValidElement)(child) && child.type === Tab2) {
      return (0, import_react46.cloneElement)(child, {
        id: `${parentId}-tab-${tabIndex++}`,
        loadingCounters,
        iconsVisible
      });
    }
    if ((0, import_react46.isValidElement)(child) && child.type === Panel3) {
      return (0, import_react46.cloneElement)(child, {
        "aria-labelledby": `${parentId}-tab-${panelIndex++}`
      });
    }
    return child;
  });
  const tabs = (0, import_react46.useRef)(import_react46.Children.toArray(childrenWithProps).filter((child) => {
    return (0, import_react46.isValidElement)(child) && child.type === Tab2;
  }));
  const tabPanels = (0, import_react46.useRef)(import_react46.Children.toArray(childrenWithProps).filter((child) => (0, import_react46.isValidElement)(child) && child.type === Panel3));
  const tabsHaveIcons = tabs.current.some((tab) => import_react46.default.isValidElement(tab) && tab.props.icon);
  const [listWidth, setListWidth] = (0, import_react46.useState)(0);
  useIsomorphicLayoutEffect(() => {
    var _listRef$current$getB, _listRef$current;
    if (!tabsHaveIcons) {
      return;
    }
    setListWidth((_listRef$current$getB = (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.getBoundingClientRect().width) !== null && _listRef$current$getB !== void 0 ? _listRef$current$getB : 0);
  }, [tabsHaveIcons]);
  useResizeObserver((resizeObserverEntries) => {
    if (!tabsHaveIcons) {
      return;
    }
    const wrapperWidth = resizeObserverEntries[0].contentRect.width;
    setIconsVisible(wrapperWidth > listWidth);
  }, wrapperRef);
  if (true) {
    const selectedTabs = tabs.current.filter((tab) => {
      const ariaSelected = import_react46.default.isValidElement(tab) && tab.props["aria-selected"];
      return ariaSelected === true || ariaSelected === "true";
    });
    !(selectedTabs.length <= 1) ? true ? invariant(false, "Only one tab can be selected at a time.") : invariant(false) : void 0;
    !(tabs.current.length === tabPanels.current.length) ? true ? invariant(false, `The number of tabs and panels must be equal. Counted ${tabs.current.length} tabs and ${tabPanels.current.length} panels.`) : invariant(false) : void 0;
  }
  return import_react46.default.createElement(TabContainerComponent, null, import_react46.default.createElement(StyledUnderlineWrapper, _extends14({
    ref: wrapperRef,
    slot: "tablist-wrapper",
    "data-icons-visible": iconsVisible,
    sx: (0, import_deepmerge4.default)({
      width: "100%",
      overflowX: "auto",
      overflowY: "hidden",
      "-webkit-overflow-scrolling": "auto",
      '&[data-icons-visible="false"] [data-component="icon"]': {
        display: "none"
      }
    }, sxProp)
  }, props), import_react46.default.createElement(StyledUnderlineItemList, {
    ref: listRef,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    role: "tablist"
  }, tabs.current)), tabPanels.current);
};
UnderlinePanels.displayName = "UnderlinePanels";
var Tab2 = ({
  "aria-selected": ariaSelected,
  sx: sxProp = defaultSxProp,
  ...props
}) => import_react46.default.createElement(UnderlineItem, _extends14({
  as: "button",
  role: "tab",
  tabIndex: ariaSelected ? 0 : -1,
  "aria-selected": ariaSelected,
  sx: sxProp
}, props));
Tab2.displayName = "Tab";
Tab2.displayName = "UnderlinePanels.Tab";
var Panel3 = (props) => {
  return import_react46.default.createElement(Box, _extends14({
    as: "div",
    role: "tabpanel"
  }, props));
};
Panel3.displayName = "Panel";
Panel3.displayName = "UnderlinePanels.Panel";
var UnderlinePanels$1 = Object.assign(UnderlinePanels, {
  Panel: Panel3,
  Tab: Tab2
});

// node_modules/@primer/react/lib-esm/DataTable/column.js
function createColumnHelper() {
  function column(column2) {
    var _column$id;
    return {
      ...column2,
      id: (_column$id = column2.id) !== null && _column$id !== void 0 ? _column$id : column2.field
    };
  }
  return {
    column
  };
}
export {
  ActionBar,
  Announce,
  AriaAlert,
  AriaStatus,
  Banner3 as Banner,
  Blankslate$1 as Blankslate,
  DataTable,
  Dialog,
  Hidden,
  InlineAutocomplete,
  InlineMessage,
  MarkdownEditor2 as MarkdownEditor,
  MarkdownViewer,
  NavList,
  PageHeader,
  ScrollableRegion,
  SelectPanel2 as SelectPanel,
  SkeletonAvatar,
  SkeletonBox,
  SkeletonText,
  Stack,
  TabPanels$1 as TabPanels,
  Table3 as Table,
  Tooltip,
  TooltipContext,
  UnderlinePanels$1 as UnderlinePanels,
  callbackCancelledResult,
  createColumnHelper,
  useCombobox,
  useDynamicTextareaHeight,
  useIgnoreKeyboardActionsWhileComposing,
  useOverflow,
  useSafeAsyncCallback,
  useSlots,
  useSyntheticChange
};
//# sourceMappingURL=@primer_react_drafts.js.map
